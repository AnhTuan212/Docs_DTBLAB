# V3__create_absence_conflict_trigger.sql - Complete Explanation

**File Purpose:** Database validation for staff absence requests (time-off management)  
**Level:** Business workflow explanation (not database theory)  
**Language:** PostgreSQL 14+

---

## TABLE OF CONTENTS

1. [File Overview](#file-overview)
2. [Function Explained](#function-explained)
3. [Trigger Explained](#trigger-explained)
4. [Trigger Execution Flow](#trigger-execution-flow)
5. [End-to-End Workflows](#end-to-end-workflows)
6. [How Backend Uses This Logic](#how-backend-uses-this-logic)
7. [Business Rules Enforced](#business-rules-enforced)
8. [Real-World Scenarios](#real-world-scenarios)
9. [Final Mental Model](#final-mental-model)

---

## FILE OVERVIEW

### What This File Does (Big Picture)

**V3__create_absence_conflict_trigger.sql** manages **staff absence requests** (time-off, vacation, sick leave) and ensures they don't create conflicts with scheduled appointments.

Think of it this way:

```
REAL WORLD (Spa Management)
└─ Problem: Staff requests time off
   ├─ Jane requests vacation Mon-Fri
   ├─ But she has appointments scheduled Mon-Wed!
   └─ Manager needs to either:
      ├─ Reject vacation (keep appointments)
      ├─ Or reschedule all her appointments

DATABASE SOLUTION (V3)
└─ Automatically validates absence requests
   ├─ Check 1: Dates are valid (end_date > start_date)
   ├─ Check 2: No overlapping absence requests (can't request time-off twice)
   ├─ Check 3: No scheduled appointments during approved absence
   └─ Block or allow request based on these checks
```

### Why This Logic is in Database (Not Backend)

| Reason | Explanation |
|--------|-------------|
| **Atomic** | All checks happen together, no race conditions |
| **Concurrent Safe** | Multiple staff requesting time-off simultaneously |
| **Enforced** | Even if backend has a bug, database validates |
| **Single Source of Truth** | One place all rules are checked |
| **Prevents Overbooking** | Can't approve absence while customers are booked |

### What Business Logic is Here?

This file handles **everything related to staff absence/time-off**:
- ✅ Validating absence request dates (end must be after start)
- ✅ Preventing duplicate absence requests (same tech can't request overlapping time-off twice)
- ✅ Preventing appointment conflicts (can't approve absence if tech has appointments)
- ✅ Managing absence status (PENDING → APPROVED, REJECTED)
- ✅ Handling concurrent requests safely

---

## FUNCTION EXPLAINED

### FUNCTION: `validate_absence_request_master()`

#### A. Purpose

**Validate that a staff member's absence/time-off request is legal before allowing it.**

Real-world example:
```
Jane submits: "I want vacation from Jan 15-20"

Database validates:
  ✓ Is Jan 20 after Jan 15? YES (valid dates)
  ✓ Does Jane already have pending vacation Jan 15-20? NO (no duplicate)
  ✓ Is this request being APPROVED? Let me check...
    - If yes: Does Jane have appointments Jan 15-20? Check...
    - If no appointments: OK, APPROVE vacation
    - If has appointments: REJECT, reschedule first

Result: ✅ Vacation request allowed or ❌ rejected
```

#### B. How It's Activated

**Automatically triggered by BEFORE INSERT OR UPDATE trigger** on the absence_request table.

When: Every time an absence request is created or modified
Timing: BEFORE the change is saved (can reject with RAISE EXCEPTION)

```
Activation Points:
├─ When technician submits new absence request (INSERT)
├─ When absence request status changes (UPDATE to APPROVED)
├─ When absence request dates are modified (UPDATE to change dates)
└─ Before saving any of these changes
```

#### C. Activation Code

```sql
-- The Trigger Definition
CREATE TRIGGER trg_validate_absence_request_master
    BEFORE INSERT OR UPDATE ON absence_request
    FOR EACH ROW
    EXECUTE FUNCTION validate_absence_request_master();

-- How Backend Calls It
@Service
public class AbsenceRequestService {
    
    @Transactional
    public AbsenceRequest submitAbsenceRequest(AbsenceRequest req) {
        // Backend just saves - trigger validates automatically
        return absenceRequestRepository.save(req);
        // If invalid: database throws exception
        // If valid: request saved successfully
    }
    
    @Transactional
    public AbsenceRequest approveRequest(Integer requestId) {
        AbsenceRequest req = absenceRequestRepository.findById(requestId)
            .orElseThrow(() -> new NotFoundException("Request not found"));
        
        // Change status to APPROVED
        req.setStatus("APPROVED");
        
        try {
            return absenceRequestRepository.save(req);
            // Trigger fires immediately when status changes to APPROVED
            // Checks if any appointments exist during this time
            // If appointments exist: throws exception, rollback
            
        } catch (DataIntegrityViolationException e) {
            throw new ConflictException("Cannot approve: " + e.getMessage());
        }
    }
}
```

#### D. Main Logic (Simplified)

```
When: Absence request is being inserted or updated

CHECK 1: Date Validation
  IF end_date <= start_date THEN
    RAISE EXCEPTION 'End date must be greater than start date'
  END IF
  (Example: Can't request vacation Jan 20-15, must be Jan 15-20)

CHECK 2: Technician Row Locking
  LOCK technician row FOR UPDATE
  (Prevents race conditions when checking appointments)

CHECK 3: No Overlapping Absence Requests
  IF exists another absence_request WHERE:
    ├─ Same technician
    ├─ Status is PENDING or APPROVED
    ├─ Dates overlap with new request
    THEN RAISE EXCEPTION 'Already have overlapping absence request'
  
  Example:
    - Jane has vacation Jan 15-20 (PENDING)
    - Jane tries to request vacation Jan 18-22
    - Database rejects: "Overlapping with existing request"

CHECK 4: No Appointment Conflicts (Only if APPROVED)
  IF NEW.status = 'APPROVED' AND (
    new INSERT OR dates changed OR status changed to APPROVED
  ) THEN
    IF exists appointment WHERE:
      ├─ Same technician
      ├─ Status is not CANCELLED
      ├─ Appointment time overlaps absence time
      THEN RAISE EXCEPTION 'Cannot approve: has scheduled appointments'
    
    Example:
      - Jane has appointments Mon 2PM, Wed 3PM
      - Manager tries to APPROVE absence Jan 15-20
      - Database rejects: "Technician has appointments during this time"

IF all checks pass:
  RETURN NEW  -- Allow request to be saved
ELSE:
  Raise exception, rollback transaction
```

#### E. Effect on Data

| Reads From | Writes To | Effect |
|---|---|---|
| absence_request | (none) | Query only - validates |
| technician | (none) | Locks row for consistency |
| appointment | (none) | Query only - checks conflicts |

**Effect:** Either allows the INSERT/UPDATE or raises an exception (rolls back transaction).

---

## TRIGGER EXPLAINED

### TRIGGER: `trg_validate_absence_request_master`

| Property | Value |
|----------|-------|
| **Table** | absence_request |
| **When** | BEFORE INSERT OR UPDATE |
| **For Each Row** | Yes (every row triggers separately) |
| **Function** | validate_absence_request_master() |
| **Effect** | Validates or rejects the change |

### How BEFORE Trigger Works

```
Timeline of approval workflow:

Step 1: Manager clicks "Approve" in admin panel
Step 2: Backend sends: UPDATE absence_request SET status='APPROVED' WHERE id=5

Step 3: ⚡ DATABASE TRIGGER FIRES (BEFORE UPDATE)
        ├─ Function runs: validate_absence_request_master()
        ├─ Checks:
        │  ├─ Date valid? YES
        │  ├─ Overlapping absences? NO
        │  ├─ Appointments conflict? NO
        ├─ Result: All checks pass
        └─ RETURN NEW (allow update)

Step 4: ⚡ DATABASE UPDATES ROW
        absence_request table: status changed to 'APPROVED'

Step 5: Database returns success to backend

Step 6: Frontend shows: "✅ Absence request approved!"
```

### What Makes This Trigger CRITICAL

```
❌ WITHOUT TRIGGER:
  Manager approves vacation: UPDATE status='APPROVED'
  Same time, customer books appointment with same tech
  Result: Tech promised 2 things! OVERBOOKING BUG

✅ WITH TRIGGER:
  Manager tries to approve vacation: UPDATE status='APPROVED'
  Trigger checks: Does tech have appointments? YES!
  Trigger rejects: "Cannot approve: has scheduled appointments"
  Manager gets error: "Reschedule appointments first"
  Result: No conflicts! ✅
```

---

## TRIGGER EXECUTION FLOW

### Scenario A: Submitting a New Absence Request (INSERT)

```
Step 1: Jane fills form: "Vacation Jan 15-20"
        Frontend sends: POST /api/absence/request
        Backend receives: {technicianId: 2, startDate: '2024-01-15', 
                          endDate: '2024-01-20', reason: 'Vacation', 
                          status: 'PENDING'}

Step 2: Backend code runs
        absenceRequestRepository.save(newRequest)
        → Sends: INSERT INTO absence_request VALUES (...)

Step 3: ⚡ TRIGGER FIRES: trg_validate_absence_request_master (BEFORE INSERT)
        Function: validate_absence_request_master()
        
        CHECK 1: Date validation
          ✓ Is '2024-01-20' > '2024-01-15'? YES, valid
        
        CHECK 2: Lock technician row
          ✓ Locked technician_id=2 for consistency
        
        CHECK 3: Overlapping absences
          ✓ Does Jane have other PENDING/APPROVED absences
            for Jan 15-20? NO
        
        CHECK 4: Appointment conflicts
          ? Is status = 'APPROVED'? NO, status = 'PENDING'
          → Skip appointment check (not needed for PENDING)
        
        Result: All checks pass → RETURN NEW

Step 4: ⚡ DATABASE INSERTS ROW
        absence_request table gets new row:
        [request_id=10, technician_id=2, start_date='2024-01-15',
         end_date='2024-01-20', status='PENDING', ...]

Step 5: Backend receives the saved request object
        → Returns to frontend with request_id=10

Step 6: Frontend shows: "✅ Absence request submitted! Waiting for approval..."
        Manager sees it in admin panel pending approval
```

### Scenario B: Manager Approves the Request (UPDATE)

```
Step 1: Manager views Jane's pending absence request
        Sees: Jan 15-20 vacation request
        Checks appointment calendar: Jane is FREE those days!
        Clicks "Approve"

Step 2: Backend code runs
        UPDATE absence_request SET status='APPROVED' WHERE request_id=10

Step 3: ⚡ TRIGGER FIRES: trg_validate_absence_request_master (BEFORE UPDATE)
        Function: validate_absence_request_master()
        
        CHECK 1: Date validation
          ✓ Is '2024-01-20' > '2024-01-15'? YES, valid
        
        CHECK 2: Lock technician row
          ✓ Locked technician_id=2
        
        CHECK 3: Overlapping absences
          ✓ No other PENDING/APPROVED absences for Jan 15-20
        
        CHECK 4: Appointment conflicts (CRITICAL - status is APPROVED!)
          ? Is status = 'APPROVED'? YES → Check appointments
          ? Does Jane have appointments Jan 15-20?
            SELECT appointment WHERE tech_id=2 AND status!='CANCELLED'
                     AND start_time < '2024-01-20' AND end_time > '2024-01-15'
            Result: NO appointments found
          → OK to approve
        
        Result: All checks pass → RETURN NEW

Step 4: ⚡ DATABASE UPDATES ROW
        absence_request table:
        [request_id=10, status changed from 'PENDING' to 'APPROVED']

Step 5: Backend receives updated request
        → Returns to frontend

Step 6: Frontend shows: "✅ Absence request approved!"
        Jane receives email: "Your vacation Jan 15-20 has been approved"
        Customers see: Jane is unavailable Jan 15-20 (can't book)
```

### Scenario C: Attempting Approval But Has Appointments (FAILURE)

```
Step 1: Jane has:
        - Appointment 1: Jan 16, 2PM (haircut)
        - Appointment 2: Jan 18, 3PM (massage)
        - Absence request: Jan 15-20

Step 2: Manager sees conflict warnings
        Admin panel shows: "⚠️ Tech has 2 appointments during this period"
        Manager can:
          ✓ Reject the vacation
          ✓ Or reschedule appointments first
        
        Manager clicks: "Reject Vacation"
        Backend: UPDATE status='REJECTED' WHERE request_id=10

Step 3: ⚡ TRIGGER FIRES (BEFORE UPDATE)
        CHECK 4: Is status='APPROVED'? NO, it's 'REJECTED'
        → Skip appointment check (only check if approving)
        Result: Passes

Step 4: ⚡ DATABASE UPDATES
        absence_request: status = 'REJECTED'
        Frontend: "Request rejected"

---

ALTERNATIVE: Manager tries to APPROVE despite warnings

Step 2B: Manager clicks: "Approve Anyway"
         Backend: UPDATE status='APPROVED' WHERE request_id=10

Step 3B: ⚡ TRIGGER FIRES (BEFORE UPDATE)
         CHECK 4: Is status='APPROVED'? YES → Check appointments!
         
         SELECT appointment WHERE tech_id=2 AND status!='CANCELLED'
                  AND start_time < '2024-01-20' AND end_time > '2024-01-15'
         Result: FOUND 2 appointments
         
         RAISE EXCEPTION: 'Cannot approve absence: Technician has 
                          scheduled appointments during this time'

Step 4B: ⚡ TRANSACTION ROLLBACK
         No update happens
         absence_request stays PENDING

Step 5B: Backend catches exception
         Returns error to frontend

Step 6B: Frontend shows: "❌ Cannot approve! Jane has 2 appointments:
                         - Jan 16, 2PM (haircut)
                         - Jan 18, 3PM (massage)
                        Reschedule appointments first."

Result: Manager must handle appointments before approving ✅
```

### Scenario D: Modifying Request Dates While APPROVED (UPDATE)

```
Step 1: Jane already has APPROVED absence: Jan 15-20
        She wants to extend it: Jan 15-25

Step 2: Backend sends: UPDATE absence_request 
        SET end_date='2024-01-25' WHERE request_id=10

Step 3: ⚡ TRIGGER FIRES (BEFORE UPDATE)
        Function: validate_absence_request_master()
        
        CHECK 1: Date valid
          ✓ '2024-01-25' > '2024-01-15'? YES
        
        CHECK 2: Lock technician
          ✓ Locked
        
        CHECK 3: Overlapping absences
          ✓ No overlapping requests
        
        CHECK 4: Appointment conflicts (CRITICAL!)
          ? Is status='APPROVED'? YES
          ? Did dates change? YES (end_date changed)
          → Check appointments again!
          
          SELECT appointment WHERE tech_id=2 AND status!='CANCELLED'
                   AND start_time < '2024-01-25' AND end_time > '2024-01-15'
          
          If Jan 21-22 has appointments: RAISE EXCEPTION
          If no appointments: RETURN NEW

Result: If she has appointments Jan 21-25, cannot extend ❌
        If clear, extension allowed ✅
```

---

## END-TO-END WORKFLOWS

### Workflow 1: Normal Absence Request Flow (Happy Path)

```
┌─────────────────────────────────────────────────────────────┐
│ REAL WORLD                                                  │
├─────────────────────────────────────────────────────────────┤
│ 1. Jane tells admin: "I need Jan 15-20 for vacation"       │
│ 2. Admin checks: Jane has no appointments those days       │
│ 3. Admin approves in admin panel                           │
│ 4. Jane sees: "Vacation approved! Enjoy!"                  │
│ 5. Customers see: Jane unavailable Jan 15-20              │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ BACKEND PROCESS                                             │
├─────────────────────────────────────────────────────────────┤
│ Step 1: Jane submits form                                  │
│         POST /api/absence/submit                           │
│         {techId: 2, start: '2024-01-15', end: '2024-01-20',│
│          reason: 'Vacation', status: 'PENDING'}            │
│                                                             │
│ Step 2: AbsenceRequestService.submitRequest(req)           │
│         absenceRequestRepository.save(req)                 │
│         → INSERT into database                             │
│                                                             │
│ Step 3: Manager approves                                   │
│         PUT /api/absence/approve/10                        │
│         {status: 'APPROVED'}                               │
│                                                             │
│ Step 4: AbsenceRequestService.approveRequest(10)           │
│         absenceRequestRepository.save(updatedReq)          │
│         → UPDATE database                                  │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ DATABASE VALIDATION (V3 TRIGGER)                            │
├─────────────────────────────────────────────────────────────┤
│ When INSERT (submit request):                              │
│   CHECK 1: Dates valid? ✓ Jan 15 < Jan 20                 │
│   CHECK 2: Lock tech row? ✓ Locked                         │
│   CHECK 3: Overlapping abs? ✓ No overlap                   │
│   CHECK 4: Appointments? ✗ Status=PENDING, skip check      │
│   Result: ✅ Request saved, status=PENDING                 │
│                                                             │
│ When UPDATE (approve):                                      │
│   CHECK 1: Dates valid? ✓ Still Jan 15-20                 │
│   CHECK 2: Lock tech row? ✓ Locked                         │
│   CHECK 3: Overlapping abs? ✓ No overlap                   │
│   CHECK 4: Appointments? ✓ Status=APPROVED, check!         │
│            SELECT appointments... → NONE FOUND             │
│   Result: ✅ Request approved, status=APPROVED             │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ FRONTEND RESULT                                             │
├─────────────────────────────────────────────────────────────┤
│ ✅ Vacation approved!                                       │
│ Jane unavailable: Jan 15-20 2024                           │
│ Customers cannot book with Jane during this time          │
└─────────────────────────────────────────────────────────────┘
```

### Workflow 2: Approval Fails Due to Appointments (Conflict)

```
┌─────────────────────────────────────────────────────────────┐
│ REAL WORLD                                                  │
├─────────────────────────────────────────────────────────────┤
│ 1. Jane submits: Vacation Jan 15-20                        │
│ 2. Admin reviews: SEES WARNING "2 appointments that week"  │
│ 3. Admin clicks "Approve" anyway (forgetting to reschedule)│
│ 4. System rejects: "Cannot approve, has appointments"      │
│ 5. Admin reschedules those 2 appointments first            │
│ 6. Admin approves again → SUCCESS                          │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ BACKEND PROCESS                                             │
├─────────────────────────────────────────────────────────────┤
│ Step 1: Jane submits (same as before)                      │
│         → INSERT success                                    │
│                                                             │
│ Step 2: Admin tries to approve immediately                 │
│         PUT /api/absence/approve/10                        │
│         UPDATE absence_request SET status='APPROVED'...    │
│                                                             │
│ Step 3: System sends request to database                   │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ DATABASE VALIDATION (V3 TRIGGER) - FAILS                   │
├─────────────────────────────────────────────────────────────┤
│ When UPDATE (approve):                                      │
│   CHECK 1: Dates valid? ✓ Jan 15-20                        │
│   CHECK 2: Lock tech row? ✓ Locked                         │
│   CHECK 3: Overlapping abs? ✓ No overlap                   │
│   CHECK 4: Appointments? ✓ Status=APPROVED, CHECK!         │
│            SELECT appointments WHERE tech_id=2             │
│                   AND start_time < '2024-01-20'            │
│                   AND end_time > '2024-01-15'              │
│                   AND status != 'CANCELLED'                │
│            Result: FOUND 2 rows!                            │
│              - Appointment 15: Jan 16, 2PM (haircut)       │
│              - Appointment 23: Jan 18, 3PM (massage)       │
│                                                             │
│   RAISE EXCEPTION: 'Cannot approve absence:                │
│    Technician has scheduled appointments during this time'  │
│                                                             │
│   ROLLBACK: No update happens                              │
│   Return error to backend                                  │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ BACKEND CATCHES ERROR                                       │
├─────────────────────────────────────────────────────────────┤
│ catch (DataIntegrityViolationException e) {                │
│   String msg = e.getCause().getMessage();                 │
│   // "Cannot approve absence: Technician has scheduled..." │
│   throw new ConflictException(msg);                        │
│ }                                                           │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ FRONTEND SHOWS ERROR                                        │
├─────────────────────────────────────────────────────────────┤
│ ❌ Cannot approve this vacation!                            │
│                                                             │
│ Technician has scheduled appointments:                     │
│ • Jan 16, 2:00 PM - Haircut (Appointment #15)             │
│ • Jan 18, 3:00 PM - Massage (Appointment #23)             │
│                                                             │
│ Please reschedule these appointments first, then approve.  │
│                                                             │
│ [Reschedule] [Cancel Request]                              │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ ADMIN RESCHEDULES APPOINTMENTS                              │
├─────────────────────────────────────────────────────────────┤
│ 1. Admin reschedules appointment 15 to Jan 21             │
│ 2. Admin reschedules appointment 23 to Jan 22             │
│ 3. Now Jan 15-20 has NO appointments                       │
│ 4. Admin clicks "Approve" again                            │
│                                                             │
│ Trigger runs again:                                         │
│   CHECK 4: Appointments? Status=APPROVED, check!           │
│            SELECT appointments... → NONE FOUND             │
│   Result: ✅ APPROVED success                              │
└─────────────────────────────────────────────────────────────┘
```

### Workflow 3: Submitting Overlapping Absence Requests

```
┌─────────────────────────────────────────────────────────────┐
│ REAL WORLD                                                  │
├─────────────────────────────────────────────────────────────┤
│ 1. Jane submits: Vacation Jan 15-20 (PENDING)             │
│ 2. Day later, Jane submits: Extended vacation Jan 18-25   │
│ 3. System rejects: "Already have overlapping absence"      │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ BACKEND & DATABASE                                          │
├─────────────────────────────────────────────────────────────┤
│ First INSERT (Jan 15-20): ✅ Success                        │
│   absence_request: [request_id=10, status=PENDING]         │
│                                                             │
│ Second INSERT (Jan 18-25):                                 │
│   TRIGGER runs:                                            │
│   CHECK 3: Overlapping absences?                           │
│            SELECT FROM absence_request                     │
│            WHERE tech_id=2                                 │
│            AND status IN ('PENDING', 'APPROVED')           │
│            AND start_date < '2024-01-25'                   │
│            AND end_date > '2024-01-18'                     │
│            AND request_id != -1 (new request)              │
│            Result: FOUND request_id=10!                    │
│            Overlap: Jan 18-20 is covered by both           │
│                                                             │
│   RAISE EXCEPTION: 'Already have another absence request   │
│                    overlapping this time period'           │
│   ROLLBACK: Insert fails                                   │
│                                                             │
│ Frontend: ❌ "You already have a vacation request for      │
│            Jan 15-20. Cannot request overlapping period.   │
│            Cancel the first request first."                │
└─────────────────────────────────────────────────────────────┘
```

---

## HOW BACKEND USES THIS LOGIC

### What Backend Actually Does

#### Step 1: Submit Absence Request

```java
@Service
public class AbsenceRequestService {
    
    @Transactional
    public AbsenceRequest submitAbsenceRequest(AbsenceRequestDTO req) {
        
        // Backend creates entity (minimal logic)
        AbsenceRequest request = new AbsenceRequest();
        request.setTechnicianId(req.getTechnicianId());
        request.setStartDate(req.getStartDate());
        request.setEndDate(req.getEndDate());
        request.setReason(req.getReason());
        request.setStatus("PENDING");  // Always starts as PENDING
        
        // Backend saves → Trigger validates
        return absenceRequestRepository.save(request);
        
        // If invalid: DataIntegrityViolationException thrown
        // If valid: Request saved with ID
    }
}
```

#### Step 2: Approve Request

```java
@Service
public class AbsenceRequestService {
    
    @Transactional(rollbackFor = Exception.class)
    public AbsenceRequest approveRequest(Integer requestId) {
        
        AbsenceRequest request = absenceRequestRepository
            .findById(requestId)
            .orElseThrow(() -> new NotFoundException("Request not found"));
        
        // Change status to APPROVED
        request.setStatus("APPROVED");
        
        try {
            // Save → Trigger validates immediately
            return absenceRequestRepository.save(request);
            
        } catch (DataIntegrityViolationException e) {
            // Trigger rejected it
            String errorMsg = e.getCause().getMessage();
            // "Cannot approve absence: Technician has scheduled..."
            throw new ConflictException(errorMsg);
        }
    }
}
```

#### Step 3: Reject Request

```java
@Transactional
public AbsenceRequest rejectRequest(Integer requestId) {
    
    AbsenceRequest request = absenceRequestRepository.findById(requestId)
        .orElseThrow(() -> new NotFoundException("Request not found"));
    
    request.setStatus("REJECTED");
    return absenceRequestRepository.save(request);
    
    // Trigger runs, but only checks dates (not appointments)
    // Because status is not APPROVED, appointment check is skipped
    // Result: Always succeeds
}
```

### What Logic Backend DOESN'T Need to Handle

| Logic | Handled By | Why |
|-------|-----------|-----|
| Date validation | Database trigger | Consistent, not in code |
| Overlapping absences | Database trigger | Single source of truth |
| Appointment conflicts | Database trigger | Atomic with UPDATE |
| Preventing bypass | Database trigger | Can't skip validation |
| Concurrent requests | Database trigger | Locking prevents race conditions |

### How Backend Receives Errors

```
Database throws error:
  PostgreSQL: RAISE EXCEPTION 'Cannot approve absence: ...'
      ↓
JDBC receives error:
  Exception: org.postgresql.util.PSQLException
  Message: "Cannot approve absence: Technician has scheduled..."
      ↓
Hibernate wraps it:
  org.springframework.dao.DataIntegrityViolationException
      ↓
Backend catches in @Service:
  catch (DataIntegrityViolationException e) {
    String msg = e.getCause().getMessage();
    throw new ConflictException(msg);
  }
      ↓
Controller catches and sends HTTP response:
  HTTP 409 Conflict
  {"error": "Cannot approve absence: Technician has scheduled..."}
      ↓
Frontend displays:
  ❌ "Cannot approve vacation - has scheduled appointments"
```

---

## BUSINESS RULES ENFORCED

### Rule 1: End Date Must Be After Start Date

```
Rule: Cannot create absence request with end_date <= start_date

Enforced by: validate_absence_request_master()
Trigger: BEFORE INSERT OR UPDATE

Example:
  ✗ REJECTED: Request with start='Jan 20', end='Jan 15'
  ✓ ALLOWED: Request with start='Jan 15', end='Jan 20'

Database:
  IF NEW.end_date <= NEW.start_date THEN
    RAISE EXCEPTION 'End date must be greater than start date'

Why important: Prevents nonsensical date ranges
```

### Rule 2: No Overlapping Absence Requests

```
Rule: Technician cannot have multiple PENDING/APPROVED absences 
      with overlapping dates

Enforced by: validate_absence_request_master()
Trigger: BEFORE INSERT OR UPDATE

Example:
  ✓ ALLOWED: Jan 15-20 vacation, then Jan 22-25 sick leave (no overlap)
  ✗ REJECTED: Jan 15-20 vacation, then Jan 18-22 extended (overlap!)

Database:
  IF EXISTS (SELECT FROM absence_request 
             WHERE tech_id = NEW.tech_id
             AND status IN ('PENDING', 'APPROVED')
             AND start_date < NEW.end_date
             AND end_date > NEW.start_date
             AND request_id != NEW.request_id) THEN
    RAISE EXCEPTION 'Already have overlapping absence request'

Why important: Prevent duplicate/conflicting time-off requests
```

### Rule 3: Cannot Approve Absence With Scheduled Appointments

```
Rule: When approving absence, technician must have NO 
      non-cancelled appointments during absence period

Enforced by: validate_absence_request_master()
Trigger: BEFORE UPDATE (only when status changes to APPROVED)

Example:
  ✓ ALLOWED: Approve Jan 15-20 vacation (0 appointments that week)
  ✗ REJECTED: Approve Jan 15-20 vacation (has appointments Jan 16, 18)

Database:
  IF NEW.status = 'APPROVED' AND (
    TG_OP='INSERT' OR status changed OR dates changed
  ) THEN
    IF EXISTS (SELECT FROM appointment
               WHERE tech_id = NEW.tech_id
               AND status != 'CANCELLED'
               AND appointment overlaps absence) THEN
      RAISE EXCEPTION 'Cannot approve: has scheduled appointments'

Why important: 
  - Prevent overbooking customers
  - Require rescheduling before approving absence
  - Professional commitment
```

### Rule 4: Optimized Checking (Only When Needed)

```
Rule: Appointment check is only done:
  a) When status is being changed to APPROVED
  b) OR when absence dates are being modified
  c) NOT when creating PENDING requests
  d) NOT when rejecting requests

Enforced by: Conditional logic in validate_absence_request_master()

Why important:
  - Performance: Don't check appointments unnecessarily
  - Flexibility: Pending requests don't block anything
  - Business logic: Approving is what matters
  
Example:
  Jane submits: Jan 15-20 vacation (PENDING)
  ✅ No appointment check (status is PENDING)
  
  Manager approves:
  ❌ Appointment check happens (status → APPROVED)
```

---

## REAL-WORLD SCENARIOS

### Scenario 1: Simple Vacation Approval

```
Monday Morning:
  Jane: "I need time off next week, Jan 15-20"
  Admin: "Sure, let me check your calendar..."
  Admin: "You're clear those days, approving now"
  System: ✅ Approved successfully
  Jane: "Thanks!"

Behind the scenes:
  INSERT with PENDING → Trigger checks dates only → ✅
  UPDATE to APPROVED → Trigger checks dates + appointments → ✅
  Result: Vacation approved, unavailable for bookings
```

### Scenario 2: Preventing Overbooking

```
Tuesday:
  Jane has haircut scheduled with customer: Jan 16, 2PM
  Admin doesn't notice
  Admin tries to approve Jan 15-20 vacation
  System: ❌ "Cannot approve - has appointment Jan 16"
  
  Admin realizes: "Oh right, Jane has appointments!"
  Admin reschedules that haircut to Feb 5
  Admin approves vacation again
  System: ✅ Now approved (no conflicts)
  
Result: Customer gets their haircut rescheduled
        Jane gets her vacation approved
        No overbooking happened ✅
```

### Scenario 3: Managing Multiple Time-Off Requests

```
Week 1:
  Jane: "I need Jan 15-17 for doctor appointment"
  Admin: ✅ Approves (PENDING → APPROVED)
  
Same day:
  Jane: "Actually, I need extended time off Jan 15-25"
  System: ❌ "Cannot request Jan 15-25, overlaps Jan 15-17 request"
  
  Jane: "OK, cancel the first one"
  Admin: ✅ Rejects Jan 15-17 request
  
  Jane: "Now request Jan 15-25"
  Admin: ✅ Approves successfully
  
Result: No duplicate/overlapping requests
        Clear timeline of what's approved
```

### Scenario 4: Updating Approved Absence Dates

```
Scenario: Jane's vacation is already approved Jan 15-20
          She wants to extend it to Jan 15-22

Backend: UPDATE absence_request SET end_date='2024-01-22' WHERE id=10

Trigger:
  CHECK 1: Dates valid? ✓ Jan 20 > Jan 15
  CHECK 2: Overlapping absences? ✓ No overlap
  CHECK 3: Status=APPROVED + dates changed? ✓ YES → check appointments!
  
  SELECT appointments for Jan 15-22:
    Result: NO appointments found
  ✓ Extension approved

Result: Vacation extended to Jan 15-22 ✅
```

---

## FINAL MENTAL MODEL

### In Short...

**V3__create_absence_conflict_trigger.sql is responsible for** managing **staff time-off requests and preventing conflicts** between absences and scheduled appointments.

**It works by:**
1. **Validating dates** (end must be after start)
2. **Preventing overlapping requests** (same tech can't request overlapping time-off twice)
3. **Blocking approval if appointments exist** (must reschedule before approving)
4. **Locking technician rows** (prevents race conditions)
5. **Optimizing checks** (only checks appointments if approving, not for pending)

### Key Principles

| Principle | Meaning | Benefit |
|-----------|---------|---------|
| **BLOCKING** | Trigger can reject changes | Prevents invalid data |
| **ATOMIC** | All checks happen together | No race conditions |
| **SMART** | Only checks what's needed | Better performance |
| **CONSISTENT** | Always enforced | Single source of truth |
| **SAFE** | Prevents overbooking | Customer satisfaction |

### Analogy

Think of V3 like **flight crew scheduling**:

```
❌ Without V3:
  Crew member: "I want time off Jan 15-20"
  Scheduler: "Granted!"
  Same day, scheduler: "Assigned you to flight Jan 18"
  Result: OVERBOOKING BUG ❌

✅ With V3:
  Crew member: "I want time off Jan 15-20"
  System: "Checking for conflicts... No flights assigned? OK!"
  System: "Time-off PENDING, awaiting approval"
  Scheduler: "Approving time-off..."
  System: "Checking again... Still no flights? Approved!"
  Result: No conflicts, clean schedule ✅
```

### Comparison: Before vs After V3

```
BEFORE V3 (No database trigger):
  Admin approves absence: UPDATE status='APPROVED'
  Same moment, customer books appointment
  Result: Tech promised 2 things! BUG ❌
  Customers upset, staff confused

AFTER V3 (With database trigger):
  Admin approves absence: UPDATE status='APPROVED'
  Trigger immediately checks appointments
  If conflict exists: ❌ Rejected
  Admin must reschedule appointments first
  Then approval succeeds
  Result: Perfect scheduling! ✅
  Everyone happy
```

### Business Impact

```
WITHOUT V3:
  Tech has appointment AND absence in same timeframe
  Customer shows up, tech is on leave
  "Where's my technician?" Angry customer!
  Revenue lost, reputation damaged

WITH V3:
  Cannot approve absence if appointments exist
  Appointments rescheduled before absence approved
  Tech either available OR on leave (never both)
  Customer shows up, sees tech (or knows in advance)
  Happy customer, clean schedule
```

---

## QUICK REFERENCE

### The 1 Function

| Function | When | Purpose |
|----------|------|---------|
| validate_absence_request_master() | BEFORE INSERT/UPDATE | Validate absence requests |

### The 1 Trigger

| Trigger | Timing | Function | Purpose |
|---------|--------|----------|---------|
| trg_validate_absence_request_master | BEFORE INSERT OR UPDATE | validate_absence_request_master() | Validate absence rules |

### The 3 Checks

| Check | When | What |
|-------|------|------|
| Date validation | Always | end_date > start_date |
| No overlapping absences | Always | No duplicate requests |
| No appointment conflicts | Only if APPROVED | Tech must be free during absence |

### The 4 Statuses

| Status | Meaning | Can Approve From |
|--------|---------|------------------|
| PENDING | Waiting for manager approval | Yes → APPROVED |
| APPROVED | Manager approved, tech unavailable | No (already approved) |
| REJECTED | Manager denied | No (dead state) |
| CANCELLED | Tech/manager cancelled | (Not used in V3) |

---

## Quick Flow Diagram

```
Technician submits absence request
         ↓
BEFORE INSERT Trigger fires
    ├─ Check dates valid
    ├─ Check no overlap
    └─ Check status=PENDING? Skip appointment check
         ↓
Request saved as PENDING
         ↓
Manager reviews request
         ↓
Manager clicks "Approve"
         ↓
BEFORE UPDATE Trigger fires
    ├─ Check dates valid
    ├─ Check no overlap
    ├─ Check status=APPROVED? ✓ YES
    │  └─ Check for appointment conflicts
    │     ├─ Has appointments? REJECT approval
    │     └─ No appointments? Allow
         ↓
Request updated to APPROVED (or fails)
         ↓
Tech unavailable for booking during dates
```

---

**Document:** V3__create_absence_conflict_trigger.sql Explanation  
**Purpose:** Understanding staff absence/time-off validation  
**Audience:** Backend engineers learning the system  
**Language:** Workflow-focused explanation

