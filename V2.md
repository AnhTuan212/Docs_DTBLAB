# V2__add_booking_logic.sql - Complete Explanation

**File Purpose:** Database functions and triggers for appointment booking, validation, and resource allocation  
**Level:** Business workflow explanation (not database theory)  
**Language:** PostgreSQL 14+

---

## TABLE OF CONTENTS

1. [File Overview](#file-overview)
2. [Functions Explained](#functions-explained)
3. [Triggers Explained](#triggers-explained)
4. [Trigger Execution Flow](#trigger-execution-flow)
5. [End-to-End Workflows](#end-to-end-workflows)
6. [How Backend Uses This Logic](#how-backend-uses-this-logic)
7. [Business Rules Enforced](#business-rules-enforced)
8. [Final Mental Model](#final-mental-model)

---

## FILE OVERVIEW

### What This File Does (Big Picture)

**V2__add_booking_logic.sql** implements the **core appointment booking system at the database level** instead of in backend code.

Think of it this way:
```
❌ Without this file:
  Backend code: "Check if technician is free, check if rooms available, 
                 check if appointment is in future, etc..."
  → 200+ lines of Java code
  → Many validation layers
  → Room for bugs

✅ With this file:
  Database automatically handles all validation
  Backend code: INSERT INTO appointment VALUES (...)
  Database triggers run automatically:
    → Calculates end time
    → Validates all rules
    → Assigns resources
    → Returns error if anything wrong
  → 10 lines of Java code
  → Single source of truth
  → Less bugs
```

### Why Move Logic to Database?

| Benefit | Explanation |
|---------|------------|
| **Single Source of Truth** | All booking rules in one place (SQL file) |
| **Atomic Transactions** | All or nothing: either booking succeeds 100% or fails 100% |
| **Concurrency Safe** | Database handles multiple users booking simultaneously |
| **No Bypass** | Even if backend has a bug, database validates |
| **Performance** | No network round-trips for validations |

### What Business Logic is Here?

This file handles **everything related to booking**:
- ✅ Finding available technicians (who can do the service + has free time)
- ✅ Validating appointments (not in past, technician skilled, no conflicts)
- ✅ Auto-calculating appointment end time
- ✅ Automatically assigning resources (rooms, equipment)
- ✅ Preventing double-booking (same technician can't be in 2 places)
- ✅ Preventing resource conflicts (same room can't be used twice)
- ✅ Handling staff absence (can't book when technician is on leave)

---

## FUNCTIONS EXPLAINED

### FUNCTION 1: `get_available_technicians()`

#### A. Purpose

**Find all technicians who CAN do a specific service at a specific time.**

Example:
```
Customer wants a massage on Monday 2PM for 90 minutes
→ get_available_technicians(service_id=5, check_time='2024-01-08 14:00')
→ Returns: [Jane (tech_id=2), Mike (tech_id=5), Sarah (tech_id=8)]
   (These 3 techs know massage AND are free 2PM-3:30PM AND not on leave)
```

#### B. How It's Activated

**Called directly by backend code** (not auto-triggered):
- When customer views available time slots
- When customer tries to book an appointment
- From AppointmentService.java → AppointmentRepository.findAvailableTechnicians()

#### C. Activation Code

```java
// How Backend Calls It
@Repository
public interface AppointmentRepository extends JpaRepository<Appointment, Integer> {
    
    @Query(value = "SELECT * FROM get_available_technicians(:serviceId, CAST(:checkTime AS TIMESTAMP))",
           nativeQuery = true)
    List<TechnicianOptionDto> findAvailableTechnicians(
        @Param("serviceId") Integer serviceId,
        @Param("checkTime") LocalDateTime checkTime
    );
}

// Usage in Service
public List<TechnicianOptionDto> getAvailableSlots(Integer serviceId, LocalDate date) {
    LocalDateTime checkTime = date.atTime(14, 0);  // 2PM
    return appointmentRepository.findAvailableTechnicians(serviceId, checkTime);
}
```

#### D. Main Logic (Simplified)

```
Step 1: Get service duration (e.g., massage = 90 minutes)
Step 2: Calculate when appointment would end
        start_time (2PM) + duration (90 min) = end_time (3:30PM)

Step 3: Find all technicians who:
        ├─ Have skill for this service (technician_services table)
        ├─ Are enabled/active (is_enabled = true)
        ├─ Have NO overlapping appointments (not busy 2PM-3:30PM)
        ├─ Have NO approved absence during this time
        └─ Return: [tech_id, technician_name]
```

**Key SQL Condition:**
```sql
-- Returns technicians where ALL these are TRUE:
WHERE ts.service_id = p_service_id                           -- Has skill
  AND u.is_enabled = true                                     -- Is active
  AND NOT EXISTS (SELECT ... FROM appointment a ...)          -- Not busy
  AND NOT EXISTS (SELECT ... FROM absence_request ar ...)     -- Not on leave
```

#### E. Effect on Data

| Reads From | Writes To | Effect |
|---|---|---|
| services | (none) | Query only (no changes) |
| technician | (none) | Query only |
| users | (none) | Query only |
| technician_services | (none) | Query only |
| appointment | (none) | Query only |
| absence_request | (none) | Query only |

**Effect:** Returns a list of available technicians (no data modified).

---

### FUNCTION 2: `calculate_appointment_end_time()`

#### A. Purpose

**Automatically calculate when an appointment ends based on service duration.**

Example:
```
Backend inserts: 
  INSERT INTO appointment (service_id=5, start_time='2024-01-08 14:00', ...)

Trigger fires automatically:
  Function runs → Finds service duration (90 minutes)
  → Sets end_time = '2024-01-08 15:30'
  ✅ Appointment now has both start AND end time
```

#### B. How It's Activated

**Automatically triggered by BEFORE INSERT trigger** on the appointment table.

When: Every time a new appointment is created
Timing: BEFORE the row is inserted (can modify the data before saving)

#### C. Activation Code

```sql
-- The Trigger Definition
CREATE TRIGGER trg_calculate_end_time
    BEFORE INSERT ON appointment        -- Runs before INSERT
    FOR EACH ROW                        -- For every row being inserted
    EXECUTE FUNCTION calculate_appointment_end_time();

-- In code, backend doesn't need to calculate:
// ❌ Backend code WITHOUT trigger (bad):
appointment.setEndTime(
    appointment.getStartTime()
    .plus(service.getDuration(), ChronoUnit.MINUTES)
);

// ✅ Backend code WITH trigger (good):
appointment.setStartTime(LocalDateTime.now());
appointment.setServiceId(5);
// Don't set end_time! Trigger will do it automatically
```

#### D. Main Logic (Simplified)

```
When: A new appointment is being inserted

Step 1: Check if this is an INSERT or UPDATE that changed start_time/service_id
Step 2: Get the service duration from services table
        Example: service_id=5 → duration=90 minutes
Step 3: Calculate end_time
        end_time = start_time + (duration * INTERVAL '1 minute')
        Example: '2PM' + 90 minutes = '3:30PM'
Step 4: Update the NEW row before it's inserted
        NEW.end_time := calculated_value
Step 5: Continue with INSERT
```

#### E. Effect on Data

| Reads From | Writes To | Effect |
|---|---|---|
| services | appointment | Sets end_time field automatically |

**Example:**
```
Input:  INSERT INTO appointment (service_id=5, start_time='14:00', customer_id=1, ...)
        (No end_time provided)

Process:
  Trigger runs → Gets service.duration = 90 minutes
  → Calculates end_time = '15:30'

Result: Row inserted with both:
        start_time='14:00'
        end_time='15:30'
```

---

### FUNCTION 3: `validate_appointment()`

#### A. Purpose

**Validate that appointment is allowed by checking all business rules.**

This is the **most important function** - it prevents invalid bookings:
- ❌ Can't book in the past
- ❌ Technician doesn't have required skill
- ❌ Technician already has appointment at that time
- ❌ Technician is on approved leave
- ❌ Not enough rooms/equipment available

#### B. How It's Activated

**Automatically triggered by BEFORE INSERT OR UPDATE trigger** on the appointment table.

When: Every time appointment is created or modified
Timing: BEFORE the change is saved (can reject the change with RAISE EXCEPTION)

#### C. Activation Code

```sql
-- The Trigger Definition
CREATE TRIGGER trg_validate_appointment
    BEFORE INSERT OR UPDATE ON appointment
    FOR EACH ROW
    EXECUTE FUNCTION validate_appointment();

-- Backend: Just INSERT, let database validate
@Service
public Appointment createAppointment(AppointmentRequest req) {
    Appointment appt = new Appointment();
    appt.setCustomerId(req.getCustomerId());
    appt.setTechnicianId(req.getTechnicianId());
    appt.setServiceId(req.getServiceId());
    appt.setStartTime(req.getStartTime());
    
    try {
        return appointmentRepository.save(appt);  // Trigger validates here
    } catch (DataIntegrityViolationException e) {
        // Database rejected it with RAISE EXCEPTION
        throw new BookingException(e.getMessage());
    }
}
```

#### D. Main Logic (Simplified)

```
When: Appointment INSERT or UPDATE happens

CHECK 1: Is appointment in the PAST?
  IF start_time < NOW() THEN
    RAISE EXCEPTION 'Cannot book appointment in the past'
  END IF

CHECK 2: Does technician have the required skill?
  IF no row in technician_services WHERE tech_id = NEW.tech_id 
    AND service_id = NEW.service_id THEN
    RAISE EXCEPTION 'Technician does not have required skill'
  END IF

CHECK 3: Is technician on APPROVED LEAVE during this time?
  IF exists absence_request WHERE tech_id = NEW.tech_id 
    AND status = 'APPROVED'
    AND start_date < NEW.end_time
    AND end_date > NEW.start_time THEN
    RAISE EXCEPTION 'Technician is on approved leave'
  END IF

CHECK 4: Does technician have OVERLAPPING APPOINTMENTS?
  IF exists appointment a WHERE a.tech_id = NEW.tech_id 
    AND a.appointment_id != NEW.appointment_id
    AND a.status != 'CANCELLED'
    AND a.start_time < NEW.end_time
    AND a.end_time > NEW.start_time THEN
    RAISE EXCEPTION 'Technician is not available in this time slot'
  END IF

CHECK 5: Are REQUIRED RESOURCES available?
  FOR EACH required_resource IN service_resource_requirement:
    Count free resources of that type during this time
    IF count < required_quantity THEN
      RAISE EXCEPTION 'Not enough resources available'
    END IF
  END FOR

IF all checks pass:
  RETURN NEW  -- Allow the appointment to be inserted/updated
ELSE:
  Database rolls back, error returned to backend
```

#### E. Effect on Data

| Reads From | Writes To | Effect |
|---|---|---|
| appointment | (none) | Query only - validates |
| technician | (none) | Query only |
| technician_services | (none) | Query only |
| absence_request | (none) | Query only |
| service_resource_requirement | (none) | Query only |
| resources | (none) | Query only |
| appointment_resource | (none) | Query only |

**Effect:** Either allows the INSERT/UPDATE or raises an exception (rolls back transaction).

---

### FUNCTION 4: `auto_assign_resource_after_booking()`

#### A. Purpose

**After appointment is created, automatically assign the required resources** (rooms, equipment) to it.

Example:
```
Appointment created for massage service:
  Massage requires: 1 ROOM + 1 MASSAGE_BED

Trigger fires:
  Function finds available ROOM (e.g., Room_A)
  Function finds available MASSAGE_BED (e.g., Bed_3)
  Inserts into appointment_resource table:
    (appointment_id=100, resource_id=5)   -- Room_A
    (appointment_id=100, resource_id=12)  -- Bed_3
  ✅ Resources now allocated
```

#### B. How It's Activated

**Automatically triggered by AFTER INSERT trigger** on the appointment table.

When: After a valid appointment has been inserted
Timing: AFTER (comes after validation and end_time calculation)

#### C. Activation Code

```sql
-- The Trigger Definition
CREATE TRIGGER trg_auto_assign_resource
    AFTER INSERT ON appointment
    FOR EACH ROW
    EXECUTE FUNCTION auto_assign_resource_after_booking();

-- Execution Order:
-- 1. Backend: INSERT INTO appointment VALUES (...)
-- 2. Trigger: trg_calculate_end_time (BEFORE INSERT)
-- 3. Trigger: trg_validate_appointment (BEFORE INSERT)
-- 4. Database: Row inserted
-- 5. Trigger: trg_auto_assign_resource (AFTER INSERT) ← This function
-- 6. Backend: Returns appointment with ID
```

#### D. Main Logic (Simplified)

```
When: Appointment has been successfully inserted (has appointment_id)

Step 1: Loop through each REQUIRED RESOURCE TYPE for this service
        Example: Massage service requires [ROOM, MASSAGE_BED]

Step 2: For each resource type:
        a) Find ONE available resource of that type
           - Must be same resource type
           - Must not be deleted
           - Must not be used during appointment time slot
           - Use "FOR UPDATE SKIP LOCKED" for safe concurrent booking
           
        b) If no available resource found:
           RAISE EXCEPTION - appointment INSERT rolls back
           
        c) If found:
           INSERT into appointment_resource (appointment_id, resource_id)
           Mark this resource as "in use"

Step 3: Return success
        Appointment now has all required resources assigned
```

**Key Detail - SKIP LOCKED:**
```sql
SELECT r.resource_id INTO v_resource_id
FROM resources r
WHERE r.type = v_req_record.resource_type
  AND r.is_deleted = FALSE
  AND NOT EXISTS (... time conflict check ...)
FOR UPDATE SKIP LOCKED  -- ← Don't wait if locked by another user
LIMIT 1;
```

Why? Prevents deadlocks when 100 customers book simultaneously.

#### E. Effect on Data

| Reads From | Writes To | Effect |
|---|---|---|
| service_resource_requirement | appointment_resource | INSERT new rows |
| resources | (reads) | Reserves resources |
| appointment_resource | (reads) | Check availability |
| appointment | (reads) | Gets appointment details |

**Example:**
```
Before:
  appointment table: [id=100, service_id=5, start_time='14:00', ...]
  appointment_resource table: (empty)

After function runs:
  appointment_resource table: 
    [id=201, appointment_id=100, resource_id=5]    -- Room_A
    [id=202, appointment_id=100, resource_id=12]   -- Bed_3
```

---

### FUNCTION 5: `handle_resource_on_update()`

#### A. Purpose

**When appointment is rescheduled (time changed), reassign resources** because old resources might not be available at new time.

Example:
```
Customer reschedules massage from Monday 2PM to Tuesday 4PM
  Old time: Monday 2PM-3:30PM (Room_A assigned)
  New time: Tuesday 4PM-5:30PM (Room_A might be booked!)

Trigger fires:
  Function removes old resource assignments (Room_A, Bed_3)
  Function finds NEW available resources for Tuesday 4PM
  Function assigns them: Room_B, Bed_1
  ✅ Appointment now has correct resources for new time
```

#### B. How It's Activated

**Automatically triggered by AFTER UPDATE trigger** on the appointment table.

When: After appointment is updated (rescheduled)
Timing: AFTER the update is applied

#### C. Activation Code

```sql
-- The Trigger Definition
CREATE TRIGGER trg_update_resource_on_reschedule
    AFTER UPDATE ON appointment
    FOR EACH ROW
    EXECUTE FUNCTION handle_resource_on_update();

-- Execution Order when rescheduling:
-- 1. Backend: UPDATE appointment SET start_time='...' WHERE id=100
-- 2. Trigger: trg_validate_appointment (BEFORE UPDATE)
-- 3. Database: Row updated
-- 4. Trigger: trg_update_resource_on_reschedule (AFTER UPDATE) ← This function
-- 5. Backend: Returns updated appointment
```

#### D. Main Logic (Simplified)

```
When: Appointment has been updated

Step 1: Check if start_time actually changed
        IF OLD.start_time = NEW.start_time THEN
          RETURN NEW  -- Exit early, no resource reassignment needed
        END IF

Step 2: Check if service requires any resources
        IF no requirements exist THEN
          RETURN NEW  -- Exit early
        END IF

Step 3: DELETE all old resource assignments
        DELETE FROM appointment_resource 
        WHERE appointment_id = NEW.appointment_id
        (Now all resources are freed)

Step 4: Find and assign NEW resources (same as auto_assign_resource)
        Loop through each required resource type:
          - Find available resource for NEW time slot
          - If not found: RAISE EXCEPTION (reschedule fails)
          - If found: INSERT into appointment_resource

Step 5: Return success
        Appointment now uses different resources suitable for new time
```

#### E. Effect on Data

| Reads From | Writes To | Effect |
|---|---|---|
| service_resource_requirement | appointment_resource | DELETE old, INSERT new |
| resources | (reads) | Re-allocates |
| appointment | (reads) | Checks time change |

**Example:**
```
Before rescheduling:
  appointment: [id=100, start_time='Mon 14:00', service_id=5]
  appointment_resource: 
    [id=201, appointment_id=100, resource_id=5]    -- Room_A
    [id=202, appointment_id=100, resource_id=12]   -- Bed_3

UPDATE appointment SET start_time='Tue 16:00' WHERE id=100

After function runs:
  appointment: [id=100, start_time='Tue 16:00', service_id=5]
  appointment_resource:
    [id=301, appointment_id=100, resource_id=7]    -- Room_C (new)
    [id=302, appointment_id=100, resource_id=15]   -- Bed_5 (new)
```

---

## TRIGGERS EXPLAINED

### Summary of All Triggers

| Trigger Name | When | What It Does | Function |
|---|---|---|---|
| `trg_calculate_end_time` | BEFORE INSERT | Auto-calculates end_time | calculate_appointment_end_time() |
| `trg_validate_appointment` | BEFORE INSERT/UPDATE | Validates all business rules | validate_appointment() |
| `trg_auto_assign_resource` | AFTER INSERT | Assigns resources after booking | auto_assign_resource_after_booking() |
| `trg_update_resource_on_reschedule` | AFTER UPDATE | Reassigns resources after rescheduling | handle_resource_on_update() |

### What is a Trigger?

A **trigger** is an **automatic action** that runs when something happens to a table.

```
Analogy:
  Trigger = "If this happens, then automatically do that"
  
  Examples in real life:
    "If fire alarm sounds, then emergency lights turn on"
    "If doorbell rings, then chime sounds"
    "If email arrives, then notification appears"
    
  In database:
    "If appointment is inserted, then calculate end_time"
    "If appointment is updated, then reassign resources"
```

### BEFORE vs AFTER Triggers

```
BEFORE trigger:
  Runs BEFORE the change is saved
  Can MODIFY the data before saving
  Can REJECT the change (RAISE EXCEPTION)
  ✅ Use for validation and calculation
  
  Timeline:
    Backend: INSERT ...
    Trigger (BEFORE): Validate & modify
    If validation fails: EXCEPTION (roll back)
    If validation passes: Save row
    Trigger (AFTER): Execute side effects

AFTER trigger:
  Runs AFTER the change is saved
  Can NOT modify the original row
  Must already be valid (BEFORE trigger passed)
  ✅ Use for related updates (like resource assignment)
  
  Timeline:
    Backend: INSERT ...
    Trigger (BEFORE): Validate & modify
    Database: Save row (now has appointment_id)
    Trigger (AFTER): Assign resources using appointment_id
    Return to backend
```

---

## TRIGGER EXECUTION FLOW

### Scenario A: Creating a New Booking (INSERT)

```
Step 1: Customer clicks "Book Now" in frontend
        Data: service_id=5 (massage), technician_id=2, 
              start_time='2024-01-08 14:00', customer_id=1

Step 2: Backend code runs
        @Service public Appointment createAppointment(...) {
            return appointmentRepository.save(appointment);  // Line that triggers everything
        }

Step 3: Database receives: INSERT INTO appointment (...)

Step 4: ⚡ TRIGGER 1 FIRES: trg_calculate_end_time (BEFORE INSERT)
        Function: calculate_appointment_end_time()
        Action: Looks up service duration (90 min)
                Calculates: end_time = 14:00 + 90min = 15:30
                Modifies NEW row: end_time = 15:30
        Result: end_time is now set before row is saved

Step 5: ⚡ TRIGGER 2 FIRES: trg_validate_appointment (BEFORE INSERT)
        Function: validate_appointment()
        Checks:
          ✓ Is 14:00 in the future? YES (valid)
          ✓ Does tech_2 have massage skill? YES (valid)
          ✓ Is tech_2 on leave at 14:00-15:30? NO (valid)
          ✓ Does tech_2 have other appointments 14:00-15:30? NO (valid)
          ✓ Are 1 ROOM + 1 MASSAGE_BED available? YES (valid)
        Result: All checks pass → RETURN NEW (allow insert)

Step 6: ⚡ TRIGGER 3 FIRES: trg_auto_assign_resource (AFTER INSERT)
        Function: auto_assign_resource_after_booking()
        Now that appointment has appointment_id = 100, function:
          - Finds available ROOM: Room_A (id=5)
          - Finds available MASSAGE_BED: Bed_3 (id=12)
          - Inserts: appointment_resource (100, 5)
          - Inserts: appointment_resource (100, 12)
        Result: Appointment now has resources assigned

Step 7: Database commit/success
        Row inserted successfully with:
          appointment_id=100
          start_time='2024-01-08 14:00'
          end_time='2024-01-08 15:30'
          status='CONFIRMED'
          (+ all resource assignments)

Step 8: Backend receives appointment object
        Returns to frontend: {id: 100, status: 'CONFIRMED', ...}

Step 9: Frontend shows: "✅ Booking confirmed! Your massage is Monday 2PM-3:30PM in Room A"
```

### Scenario B: Rescheduling a Booking (UPDATE)

```
Step 1: Customer clicks "Reschedule" for appointment_id=100
        New time: '2024-01-09 16:00' (Tuesday 4PM instead of Monday 2PM)

Step 2: Backend code runs
        UPDATE appointment SET start_time='2024-01-09 16:00' WHERE id=100

Step 3: ⚡ TRIGGER 1 FIRES: trg_calculate_end_time (BEFORE UPDATE)
        Only if start_time OR service_id changed (both did!)
        Function: calculate_appointment_end_time()
        Action: Gets service duration (90 min)
                Calculates: end_time = 16:00 + 90min = 17:30
                Modifies NEW row: end_time = 17:30
        Result: end_time updated to 17:30

Step 4: ⚡ TRIGGER 2 FIRES: trg_validate_appointment (BEFORE UPDATE)
        Function: validate_appointment()
        Checks (same as INSERT):
          ✓ Is 16:00 in the future? YES (valid)
          ✓ Does tech_2 have massage skill? YES (still valid)
          ✓ Is tech_2 on leave at 16:00-17:30? NO (different day, valid)
          ✓ Does tech_2 have other appointments 16:00-17:30? NO (valid)
          ✓ Are 1 ROOM + 1 MASSAGE_BED available at new time? YES (valid)
        Result: All checks pass → RETURN NEW (allow update)

Step 5: ⚡ TRIGGER 3 FIRES: trg_update_resource_on_reschedule (AFTER UPDATE)
        Function: handle_resource_on_update()
        Action:
          - Checks if start_time changed: YES → continue
          - Checks if service has requirements: YES (ROOM + MASSAGE_BED)
          - DELETEs old assignments:
              DELETE appointment_resource WHERE appointment_id=100
              (Removes: Room_A, Bed_3)
          - Finds new available resources for Tuesday 16:00-17:30:
              Room_C available (id=7)
              Bed_5 available (id=15)
          - Assigns new resources:
              INSERT appointment_resource (100, 7)
              INSERT appointment_resource (100, 15)
        Result: Appointment now uses Room_C and Bed_5 instead

Step 6: Database commit/success
        Appointment updated with:
          start_time='2024-01-09 16:00'
          end_time='2024-01-09 17:30'
          (Old resource assignments deleted, new ones assigned)

Step 7: Backend receives updated appointment object

Step 8: Frontend shows: "✅ Rescheduled! Your massage is now Tuesday 4PM-5:30PM in Room C"
```

### Scenario C: Trying to Book But Technician is Busy (FAILURE)

```
Step 1: Customer tries to book massage with tech_2
        Time: Monday 14:00-15:30
        (But tech_2 already has haircut at Monday 14:30-15:00)

Step 2: Backend sends: INSERT INTO appointment (...)

Step 3: ⚡ TRIGGER 1: trg_calculate_end_time (BEFORE INSERT)
        ✓ Calculates end_time = 15:30
        Result: Passes

Step 4: ⚡ TRIGGER 2: trg_validate_appointment (BEFORE INSERT)
        ✓ Is in future? YES
        ✓ Tech has skill? YES
        ✓ Not on leave? YES
        ✗ Overlapping appointments? 
           YES! Existing haircut 14:30-15:00 overlaps 14:00-15:30
           
        RAISE EXCEPTION: 'Technician is not available in this time slot'
        
        Result: FAILS → Transaction rolls back
                No row inserted
                No resources assigned

Step 5: Database sends error back to backend
        Error message: "Technician is not available in this time slot"

Step 6: Backend code catches exception
        @Service public Appointment createAppointment(...) {
            try {
                return appointmentRepository.save(appointment);
            } catch (DataIntegrityViolationException e) {
                throw new BookingException("Technician not available");
            }
        }

Step 7: Frontend shows: "❌ Sorry! That technician is busy at this time"
```

---

## END-TO-END WORKFLOWS

### Workflow 1: Creating a Booking (Happy Path)

```
REAL WORLD
├─ Customer: "I want massage on Monday 2PM"
├─ Frontend: Shows 3 available technicians (via get_available_technicians)
├─ Customer: Picks "Jane" and clicks "Confirm"
└─ Frontend sends: POST /api/bookings {serviceId:5, technicianId:2, startTime:'14:00'}

BACKEND
├─ AppointmentController.createBooking(req)
│  └─ AppointmentService.createAppointment(req)
│     └─ appointmentRepository.save(appointment)
│        └─ Sends INSERT to database
└─ Waits for response...

DATABASE TRIGGERS
├─ BEFORE INSERT: trg_calculate_end_time
│  └─ Sets end_time = 15:30
├─ BEFORE INSERT: trg_validate_appointment
│  └─ ✓ Validates all rules
├─ INSERT happens: appointment_id=100 created
├─ AFTER INSERT: trg_auto_assign_resource
│  └─ Assigns Room_A (id=5), Bed_3 (id=12)
└─ COMMIT success

BACKEND (continues)
├─ Receives: {id:100, status:'CONFIRMED', startTime:'14:00', endTime:'15:30'}
└─ Returns to frontend

FRONTEND
├─ Shows: "✅ Booking confirmed!"
├─ Shows: "Appointment #100"
├─ Shows: "Monday 2PM-3:30PM with Jane in Room A"
└─ Customer receives email with confirmation

RESULT: Customer has booked appointment ✅
```

### Workflow 2: Rescheduling a Booking

```
REAL WORLD
├─ Customer: "Can I move my appointment to tomorrow 4PM instead?"
├─ Frontend: Checks availability for tomorrow 4PM
├─ Customer: "Yes that works" and clicks "Reschedule"
└─ Frontend sends: PUT /api/bookings/100 {startTime:'16:00'}

BACKEND
├─ AppointmentController.updateBooking(100, req)
│  └─ AppointmentService.updateAppointment(100, req)
│     └─ appointmentRepository.save(appointment)
│        └─ Sends UPDATE to database
└─ Waits for response...

DATABASE TRIGGERS
├─ BEFORE UPDATE: trg_calculate_end_time
│  └─ Sets end_time = 17:30 (for new time)
├─ BEFORE UPDATE: trg_validate_appointment
│  └─ ✓ Validates that new time slot is free
├─ UPDATE happens: start_time changed to 16:00
├─ AFTER UPDATE: trg_update_resource_on_reschedule
│  ├─ Detects start_time changed → proceed
│  ├─ Deletes old assignments (Room_A, Bed_3)
│  ├─ Checks if resources available at new time
│  ├─ Assigns new: Room_C (id=7), Bed_5 (id=15)
│  └─ If fails: RAISE EXCEPTION, rollback everything
└─ COMMIT success

BACKEND (continues)
├─ Receives: {id:100, startTime:'16:00', endTime:'17:30', ...}
└─ Returns to frontend

FRONTEND
├─ Shows: "✅ Rescheduled!"
├─ Shows: "Appointment #100"
├─ Shows: "Tuesday 4PM-5:30PM with Jane in Room C"
└─ Customer receives email with new time

RESULT: Appointment rescheduled, resources updated ✅
```

### Workflow 3: Booking Fails (No Resources)

```
REAL WORLD
├─ Customer: "Can I book the deluxe spa package?"
├─ Frontend: Finds available technician (Jane on Monday 2PM)
├─ Customer: Clicks "Book"
├─ Backend: Tries to create appointment
└─ Database rejects with error

DATABASE TRIGGERS
├─ BEFORE INSERT: trg_calculate_end_time ✓ passes
├─ BEFORE INSERT: trg_validate_appointment
│  ├─ ✓ Tech has skill
│  ├─ ✓ Tech not busy
│  ├─ ✓ Tech not on leave
│  ├─ ✗ NOT enough resources!
│  │  Deluxe package needs 3 VIP ROOMs
│  │  Only 1 VIP room available at that time
│  └─ RAISE EXCEPTION: 'Not enough resources (VIP_ROOM) available'
├─ ROLLBACK: No row inserted
├─ ROLLBACK: No resource assignments
└─ Error returned to backend

BACKEND
├─ Catches exception
├─ Converts to user-friendly message
└─ Sends to frontend: "We're sorry, VIP suites are booked. Try another time."

FRONTEND
├─ Shows: "❌ Not available"
├─ Shows: "VIP facilities are unavailable at that time"
├─ Suggests: "Try tomorrow at 2PM" (showing get_available_technicians results)
└─ Customer can rebook

RESULT: Booking rejected, data stays clean ❌
```

---

## HOW BACKEND USES THIS LOGIC

### What Backend Actually Does

#### Step 1: Get Available Technicians (Read-only query)

```java
@Service
public class AppointmentService {
    
    // When user is checking availability
    public List<TechnicianOptionDto> getAvailableSlots(
            Integer serviceId, LocalDateTime dateTime) {
        
        // Call PostgreSQL function directly
        return appointmentRepository.findAvailableTechnicians(
            serviceId, 
            dateTime
        );
        
        // Database returns list of technicians
        // Backend doesn't validate anything here
        // Database already did all validation
    }
}
```

#### Step 2: Create Appointment (Database validates)

```java
@Service
public class AppointmentService {
    
    @Transactional(rollbackFor = Exception.class)
    public Appointment createAppointment(BookingRequest req) {
        
        // Backend does MINIMAL work
        Appointment appt = new Appointment();
        appt.setCustomerId(req.getCustomerId());
        appt.setTechnicianId(req.getTechnicianId());
        appt.setServiceId(req.getServiceId());
        appt.setStartTime(req.getStartTime());
        
        // DON'T set endTime - trigger will calculate it
        // DON'T assign resources - trigger will assign them
        // DON'T validate rules - trigger will validate them
        
        try {
            // Just save - triggers will handle everything
            return appointmentRepository.save(appt);
            
        } catch (DataIntegrityViolationException e) {
            // Database rejected it with RAISE EXCEPTION
            // Error message comes from SQL RAISE EXCEPTION
            String errorMsg = e.getCause().getMessage();
            throw new BookingException(errorMsg);
        }
    }
}
```

#### Step 3: Handle Errors

```java
@RestController
@RequestMapping("/api/bookings")
public class BookingController {
    
    @PostMapping
    public ResponseEntity<?> createBooking(@RequestBody BookingRequest req) {
        try {
            Appointment booked = appointmentService.createAppointment(req);
            return ResponseEntity.ok(new BookingResponse(booked));
            
        } catch (BookingException e) {
            // Error came from database validation
            return ResponseEntity.badRequest().body(new ErrorResponse(
                e.getMessage()  // E.g., "Technician is not available in this time slot"
            ));
        }
    }
}
```

### What Logic Backend DOESN'T Need to Handle

| Logic | Handled By | Why |
|-------|-----------|-----|
| Calculate end_time | Database trigger | Automatic, consistent |
| Validate appointment rules | Database trigger | Single source of truth |
| Check technician availability | Database trigger | Prevents race conditions |
| Check resource availability | Database trigger | Atomic with INSERT |
| Assign resources | Database trigger | Uses appointment_id |
| Prevent double-booking | Database trigger | BEFORE INSERT can reject |
| Validate past dates | Database trigger | Enforced every time |

### Backend Code Before vs After V2

```java
// ❌ BEFORE V2 (without database functions/triggers)
// Lots of validation in Java code

public Appointment createAppointment(BookingRequest req) {
    // Validate appointment not in past
    if (req.getStartTime().isBefore(LocalDateTime.now())) {
        throw new BookingException("Cannot book in past");
    }
    
    // Check technician exists
    Technician tech = technicianRepository.findById(req.getTechnicianId())
        .orElseThrow(() -> new NotFoundException("Technician not found"));
    
    // Check technician skill
    if (!tech.getServices().contains(req.getServiceId())) {
        throw new BookingException("Tech does not have skill");
    }
    
    // Calculate end time
    Service service = serviceRepository.findById(req.getServiceId())
        .orElseThrow(() -> new NotFoundException("Service not found"));
    LocalDateTime endTime = req.getStartTime()
        .plus(service.getDuration(), ChronoUnit.MINUTES);
    req.setEndTime(endTime);
    
    // Check for overlapping appointments
    List<Appointment> conflicts = appointmentRepository
        .findByTechnicianIdAndTimeRange(
            req.getTechnicianId(),
            req.getStartTime(),
            endTime
        );
    if (!conflicts.isEmpty()) {
        throw new BookingException("Technician not available");
    }
    
    // Check for absence request
    AbsenceRequest absence = absenceRepository
        .findByTechnicianIdAndTimeRange(...)
        .filter(ar -> ar.getStatus() == 'APPROVED')
        .orElse(null);
    if (absence != null) {
        throw new BookingException("Tech on leave");
    }
    
    // Check resource availability
    List<ServiceResourceRequirement> reqs = resourceReqRepository
        .findByServiceId(req.getServiceId());
    for (ServiceResourceRequirement req : reqs) {
        List<Resource> available = resourceRepository
            .findAvailableByType(
                req.getResourceType(),
                req.getStartTime(),
                endTime
            );
        if (available.size() < req.getQuantity()) {
            throw new BookingException("Not enough resources");
        }
    }
    
    // Finally create appointment
    Appointment appt = new Appointment();
    appt.setCustomerId(req.getCustomerId());
    appt.setTechnicianId(req.getTechnicianId());
    appt.setServiceId(req.getServiceId());
    appt.setStartTime(req.getStartTime());
    appt.setEndTime(endTime);
    Appointment saved = appointmentRepository.save(appt);
    
    // Assign resources
    for (ServiceResourceRequirement req : reqs) {
        List<Resource> available = resourceRepository
            .findAvailableByType(req.getResourceType(), ...);
        for (int i = 0; i < req.getQuantity(); i++) {
            AppointmentResource ar = new AppointmentResource();
            ar.setAppointmentId(saved.getId());
            ar.setResourceId(available.get(i).getId());
            appointmentResourceRepository.save(ar);
        }
    }
    
    return saved;
}
// Lines of code: ~80
// Places bugs can happen: ~20
// Database consistency issues: HIGH


// ✅ AFTER V2 (with database functions/triggers)
// Minimal validation in Java

public Appointment createAppointment(BookingRequest req) {
    Appointment appt = new Appointment();
    appt.setCustomerId(req.getCustomerId());
    appt.setTechnicianId(req.getTechnicianId());
    appt.setServiceId(req.getServiceId());
    appt.setStartTime(req.getStartTime());
    
    try {
        return appointmentRepository.save(appt);
    } catch (DataIntegrityViolationException e) {
        throw new BookingException(e.getCause().getMessage());
    }
}
// Lines of code: ~10
// Places bugs can happen: ~1
// Database consistency: GUARANTEED
```

### How Errors Flow Back to Backend

```
Database executes trigger:
  RAISE EXCEPTION 'Technician is not available in this time slot'

PostgreSQL sends error to JDBC driver:
  Exception: org.postgresql.util.PSQLException
  Message: "Technician is not available in this time slot"

Hibernate catches it:
  Converts to: org.springframework.dao.DataIntegrityViolationException

Spring catches it:
  In @Service: catch (DataIntegrityViolationException e)
  Gets message: e.getCause().getMessage()

Backend handles it:
  Sends HTTP 400: {"error": "Technician is not available in this time slot"}

Frontend shows:
  "❌ Sorry! That technician is busy at this time"
```

---

## BUSINESS RULES ENFORCED

This SQL file enforces **8 critical business rules**:

### Rule 1: No Past Bookings

```
Rule: Cannot book appointments in the past

Enforced by: validate_appointment() function
Trigger: BEFORE INSERT OR UPDATE

Example:
  ✓ ALLOWED: Book for tomorrow 2PM
  ✗ REJECTED: Book for yesterday 2PM
  
Database: IF NEW.start_time < CURRENT_TIMESTAMP THEN
            RAISE EXCEPTION 'Cannot book an appointment in the past'

Why important: Prevents accidental/malicious past bookings
```

### Rule 2: Technician Must Have Required Skill

```
Rule: Cannot assign service to technician who doesn't know how to do it

Enforced by: validate_appointment() function
Trigger: BEFORE INSERT OR UPDATE

Example:
  ✓ ALLOWED: Book massage with Jane (she knows massage)
  ✗ REJECTED: Book haircut with John (he only knows facials)
  
Database: IF NOT EXISTS (SELECT ... FROM technician_services 
                          WHERE tech_id = NEW.tech_id 
                          AND service_id = NEW.service_id) THEN
            RAISE EXCEPTION 'Technician does not have required skill'

Why important: Quality control - only skilled staff do services
```

### Rule 3: No Double-Booking (Technician)

```
Rule: Same technician cannot have 2 appointments at overlapping times

Enforced by: validate_appointment() function
Trigger: BEFORE INSERT OR UPDATE

Example:
  ✓ ALLOWED: Jane has haircut 2PM-3PM and massage 3:30PM-5PM (no overlap)
  ✗ REJECTED: Jane has haircut 2PM-3PM and massage 2:30PM-4PM (overlap!)
  
Database: IF EXISTS (SELECT ... FROM appointment a 
                      WHERE a.tech_id = NEW.tech_id
                      AND a.status != 'CANCELLED'
                      AND a.start_time < NEW.end_time
                      AND a.end_time > NEW.start_time) THEN
            RAISE EXCEPTION 'Technician is not available in this time slot'

Why important: Prevent technician from being in 2 places at once
```

### Rule 4: No Booking During Approved Absence

```
Rule: Cannot book appointment when technician is on approved leave

Enforced by: validate_appointment() function
Trigger: BEFORE INSERT OR UPDATE

Example:
  ✓ ALLOWED: Book Jane on Monday (she's not on leave)
  ✗ REJECTED: Book Jane on Tuesday (she has approved vacation Tue-Thu)
  
Database: IF EXISTS (SELECT ... FROM absence_request ar
                      WHERE ar.tech_id = NEW.tech_id
                      AND ar.status = 'APPROVED'
                      AND ar.start_date < NEW.end_time
                      AND ar.end_date > NEW.start_time) THEN
            RAISE EXCEPTION 'Technician is on approved leave'

Why important: Respect staff time off - maintain morale
```

### Rule 5: Auto-Calculate End Time

```
Rule: Appointment end_time is automatically calculated from start_time + service duration

Enforced by: calculate_appointment_end_time() function
Trigger: BEFORE INSERT OR UPDATE

Example:
  Backend sends: start_time='14:00', service_id=5 (massage, 90 min duration)
  Database sets: end_time = '15:30' automatically
  ✓ User doesn't specify end_time
  ✓ Database calculates it
  
Database: NEW.end_time := NEW.start_time + (service.duration * INTERVAL '1 minute')

Why important: No manual calculation errors - single source of truth
```

### Rule 6: Resources Must Be Available

```
Rule: Cannot book if required resources (rooms, equipment) are not available

Enforced by: validate_appointment() function
Trigger: BEFORE INSERT OR UPDATE

Example:
  Service requires: 1 ROOM + 1 MASSAGE_BED
  At 2PM-3:30PM only 0 rooms are free (all booked)
  ✗ REJECTED: Not enough ROOM available
  
Database: FOR EACH resource_type in service requirements:
            Count free resources
            IF count < required_quantity THEN
              RAISE EXCEPTION 'Not enough resources available'

Why important: Prevent overbooking facilities - quality of service
```

### Rule 7: Auto-Assign Available Resources

```
Rule: After appointment is created, automatically assign available resources

Enforced by: auto_assign_resource_after_booking() function
Trigger: AFTER INSERT

Example:
  Appointment created for massage at 2PM
  Trigger automatically:
    - Finds free ROOM (Room_A)
    - Finds free MASSAGE_BED (Bed_3)
    - Assigns them to appointment
  ✓ Resources allocated automatically
  ✓ No manual intervention needed
  
Database: FOR EACH resource_type in requirements:
            Find available resource
            INSERT into appointment_resource

Why important: Efficient resource allocation - no manual admin work
```

### Rule 8: Reassign Resources on Reschedule

```
Rule: When appointment time changes, resources are reassigned for new time

Enforced by: handle_resource_on_update() function
Trigger: AFTER UPDATE

Example:
  Appointment moved from Monday 2PM to Tuesday 4PM
  Old resources: Room_A (busy at new time) → freed
  New resources: Room_C (free at new time) → assigned
  ✓ Resources automatically updated
  ✓ Appointment time flexible
  
Database: DELETE old appointment_resource assignments
          Find and assign new resources for new time
          IF fails: EXCEPTION, rollback reschedule

Why important: Handle changes smoothly - customer satisfaction
```

---

## FINAL MENTAL MODEL

### In Short...

**V2__add_booking_logic.sql is responsible for** making the appointment booking system **atomic, consistent, and safe at the database level**.

**It works by:**
1. **Calculating** appointment end time automatically (no human math errors)
2. **Validating** that bookings are legal (not past, tech skilled, no conflicts)
3. **Preventing** race conditions (when 100 customers book simultaneously)
4. **Assigning** resources automatically (rooms, equipment)
5. **Enforcing** business rules that can't be bypassed (even if backend has a bug)
6. **Rolling back** entire transaction if anything fails (all or nothing)

### Key Principles

| Principle | Meaning | Benefit |
|-----------|---------|---------|
| **ATOMICITY** | All steps succeed or all roll back | No partial bookings |
| **CONSISTENCY** | Rules always enforced | No invalid data in DB |
| **VALIDATION** | Checks before allowing change | Errors caught early |
| **AUTOMATION** | Triggers run automatically | Less code in backend |
| **TRANSACTIONAL** | Changes grouped together | Safe concurrent access |

### Analogy

Think of V2 like **airport security**:

```
❌ Without V2 (no security):
  Each gate agent checks if you have ticket
  Each agent uses their own rules
  Someone might forget to check
  Inconsistent (one person lets through someone without passport)
  
✅ With V2 (systematic security):
  ONE SET OF RULES for everyone
  Automated gates that enforce rules
  Can't bypass (even if agent forgets)
  Consistent, safe, predictable
```

Similarly:
- **V2 functions** = Security rules
- **V2 triggers** = Automated gates
- **Backend code** = Gate agent (doesn't need to check, gate does it)
- **Database** = Security checkpoint (enforces rules)

### Visual Summary

```
BEFORE V2:                           AFTER V2:
────────────────────────────────────────────────────────

Backend: Check if available         Backend: Just INSERT
Backend: Calculate time             Database: Calculate time
Backend: Validate rules             Database: Validate rules
Backend: Assign resources           Database: Assign resources
Backend: Handle errors              Database: Handle errors

Result: Lots of code                Result: Simple code
Result: Possible bugs               Result: No bugs
Result: Slow validation             Result: Fast validation
Result: Inconsistent rules          Result: Consistent rules
```

### Business Impact

```
BEFORE V2:
  Customer 1: Books massage at 2PM
  Customer 2: Books same tech at 2PM (at same time!)
  Result: OVERBOOKING BUG ❌

AFTER V2:
  Customer 1: Books massage at 2PM
  Database: Locks technician row, books customer 1
  Customer 2: Tries to book same tech at 2PM
  Database: Checks validation, finds conflict
  Database: RAISE EXCEPTION
  Result: Customer 2 rejected ✅
```

---

## QUICK REFERENCE

### The 5 Functions

| # | Function | When | Purpose |
|---|----------|------|---------|
| 1 | get_available_technicians() | Called from backend | Find free technicians |
| 2 | calculate_appointment_end_time() | BEFORE INSERT | Auto-calc end time |
| 3 | validate_appointment() | BEFORE INSERT/UPDATE | Validate rules |
| 4 | auto_assign_resource_after_booking() | AFTER INSERT | Assign resources |
| 5 | handle_resource_on_update() | AFTER UPDATE | Reassign on reschedule |

### The 4 Triggers

| Trigger | Timing | Function | Purpose |
|---------|--------|----------|---------|
| trg_calculate_end_time | BEFORE INSERT | Function 2 | Calculate end time |
| trg_validate_appointment | BEFORE INSERT/UPDATE | Function 3 | Validate rules |
| trg_auto_assign_resource | AFTER INSERT | Function 4 | Assign resources |
| trg_update_resource_on_reschedule | AFTER UPDATE | Function 5 | Reassign resources |

### The 8 Rules

1. ✅ No past bookings
2. ✅ Tech must have skill
3. ✅ No double-booking
4. ✅ No booking during absence
5. ✅ Auto-calculate end time
6. ✅ Resources must be available
7. ✅ Auto-assign resources
8. ✅ Reassign on reschedule

---

**Document:** V2__add_booking_logic.sql Explanation  
**Purpose:** Understanding database-level business logic  
**Audience:** Backend engineers learning the system  
**Language:** Non-technical workflow explanation

