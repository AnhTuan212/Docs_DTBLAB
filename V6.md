# V6__seed_data.sql - Complete Explanation

**File Purpose:** Populate database with test/demo data  
**Level:** Business workflow explanation (not database theory)  
**Language:** PostgreSQL 14+

---

## TABLE OF CONTENTS

1. [File Overview](#file-overview)
2. [Seed Data Categories](#seed-data-categories)
3. [Procedure Explanation](#procedure-explanation)
4. [How Backend Uses This Data](#how-backend-uses-this-data)
5. [Business Rules](#business-rules)
6. [Real-World Scenarios](#real-world-scenarios)
7. [End-to-End Workflow](#end-to-end-workflow)
8. [Final Mental Model](#final-mental-model)

---

## FILE OVERVIEW

### What This File Does (Big Picture)

**V6__seed_data.sql is NOT business logic.** It's a **setup/initialization file** that populates the database with realistic test data for development and testing.

Think of it this way:

```
NEW DATABASE (Empty)
├─ users table: 0 rows
├─ appointment table: 0 rows
├─ services table: 0 rows
└─ resources table: 0 rows

Problem: 
  Backend developers need data to test with
  UI testers need realistic scenarios
  Performance testing needs large datasets
  Manual QA needs to click through real data

SOLUTION: V6 SEED DATA
├─ Creates 20,000 customers
├─ Creates 500,000 appointments
├─ Creates 50 technicians
├─ Creates 20+ services
├─ Adds realistic absence requests
└─ Database now ready for testing/development!
```

### Why This File Exists

| Purpose | Details |
|---------|---------|
| **Development** | Developers need realistic data to code against |
| **Testing** | QA needs scenarios to test |
| **Performance** | Large datasets (500k records) for load testing |
| **Demos** | Shows how system works with real data |
| **Learning** | New team members see how system populates |

### What This File Does NOT Do

- ❌ Define business logic (no functions/triggers)
- ❌ Validate data (assumes data is valid)
- ❌ Enforce constraints (only inserts)
- ❌ Create procedures (only executes them)
- ❌ Modify existing data (only inserts new)

---

## SEED DATA CATEGORIES

### Category 1: STATIC DATA (Services & Resources)

#### A. Services (20 records)

**Purpose:** Create 20 different spa/salon services with varying prices and durations.

```
Generated:
├─ Service 1: $87.50, 30 minutes
├─ Service 2: $234.25, 60 minutes
├─ Service 3: $501.00, 90 minutes
├─ ...
└─ Service 20: $145.75, 120 minutes

Data Structure:
{
  service_id: 1,
  name: "Service 1",
  description: "Auto generated 1",
  price: 87.50,
  duration_minutes: 30,
  is_active: true
}
```

**How it's created:**

```sql
INSERT INTO services (name, description, price, duration_minutes, is_active)
SELECT
    'Service ' || gs,                           -- Name: "Service 1", "Service 2", etc.
    'Auto generated ' || gs,                    -- Description
    (random() * 500 + 50)::DECIMAL(10,2),      -- Random price: $50-$550
    (ARRAY[30,60,90,120])[floor(random()*4)+1], -- Random duration: 30/60/90/120 min
    true
FROM generate_series(1, 20) gs                  -- Generate 20 rows
```

#### B. Resources (80 records)

**Purpose:** Create rooms, VIP rooms, and devices needed for services.

```
Generated:
├─ ROOM: Room 1-50 (50 regular rooms)
├─ VIP_ROOM: VIP Room 1-10 (10 premium rooms)
└─ DEVICE: Device 1-20 (20 spa devices)

Data Structure:
{
  resource_id: 1,
  name: "Room 1",
  type: "ROOM",
  is_deleted: false
}
```

**How it's created:**

```sql
INSERT INTO resources (name, type, is_deleted)
SELECT 'Room ' || gs, 'ROOM', false FROM generate_series(1, 50) gs
UNION ALL
SELECT 'VIP Room ' || gs, 'VIP_ROOM', false FROM generate_series(1, 10) gs
UNION ALL
SELECT 'Device ' || gs, 'DEVICE', false FROM generate_series(1, 20) gs
```

#### C. Service-Resource Requirements

**Purpose:** Define what resources each service needs (rooms, devices, VIP rooms).

```
Rule:
├─ Every service NEEDS 1 ROOM (mandatory)
├─ Every service NEEDS 1 DEVICE (mandatory)
└─ 50% of services CAN USE 1 VIP_ROOM (optional)

Example:
  Service 1:
    ├─ REQUIRES: Room
    ├─ REQUIRES: Device
    └─ MAY USE: VIP Room (50% chance)
```

### Category 2: USERS (20,050 records)

#### A. Technicians (50 records)

**Purpose:** Create staff members who perform services.

```
Generated:
├─ Tech 1: tech1@aura.com
├─ Tech 2: tech2@aura.com
├─ ...
└─ Tech 50: tech50@aura.com

Data Structure:
{
  user_id: 1,
  name: "Tech 1",
  email: "tech1@aura.com",
  role: "TECHNICIAN",
  is_enabled: true
}
```

**How it's created:**

```sql
DO $$
DECLARE v_user_id INT;
BEGIN
  FOR i IN 1..50 LOOP
    INSERT INTO users (name, email, password, role, is_enabled)
    VALUES ('Tech ' || i, 'tech' || i || '@aura.com', '$2a$10$Fake', 'TECHNICIAN', true)
    RETURNING user_id INTO v_user_id;
    
    INSERT INTO technician (user_id) VALUES (v_user_id);
    
    -- Random services: Each tech knows ~50% of services
    INSERT INTO technician_services (technician_id, service_id)
    SELECT t.technician_id, s.service_id
    FROM technician t
    JOIN services s ON random() < 0.5
    WHERE t.user_id = v_user_id;
  END LOOP;
END $$;
```

#### B. Customers (20,000 records)

**Purpose:** Create customers who book appointments.

```
Generated:
├─ Cust 1: cust1@mail.com (created 0-730 days ago)
├─ Cust 2: cust2@mail.com (created 0-730 days ago)
├─ ...
└─ Cust 20000: cust20000@mail.com (created 0-730 days ago)

Data Structure:
{
  user_id: 52,
  name: "Cust 1",
  email: "cust1@mail.com",
  role: "CUSTOMER",
  created_at: 2024-06-15 (random past date)
}
```

**How it's created:**

```sql
FOR i IN 1..20000 LOOP
  INSERT INTO users (name, email, password, role, created_at)
  VALUES (
    'Cust ' || i,
    'cust' || i || '@mail.com',
    '$2a$10$Fake',
    'CUSTOMER',
    NOW() - (random() * 730 * INTERVAL '1 day')  -- Random date up to 2 years ago
  )
  RETURNING user_id INTO v_user_id;
  
  INSERT INTO customer (user_id) VALUES (v_user_id);
END LOOP;
```

### Category 3: APPOINTMENTS (500,000 records)

#### A. Purpose

**Create 500,000 appointment records** spread across 2 years to simulate busy spa operation.

#### B. How It's Created

Uses a **procedure with batch processing** to handle 500k records safely:

```sql
CREATE OR REPLACE PROCEDURE seed_appointments(p_batch_size INT)
LANGUAGE plpgsql
AS $$
  -- Procedure that inserts p_batch_size appointment records
END $$;

-- Called 10 times with 50,000 records each
CALL seed_appointments(50000);  -- Appointment 1-50,000
CALL seed_appointments(50000);  -- Appointment 50,001-100,000
...
CALL seed_appointments(50000);  -- Appointment 450,001-500,000
```

#### C. Appointment Data Generated

```
For each of 500,000 appointments:
  {
    appointment_id: 1-500,000,
    customer_id: Random from 20,000 customers,
    technician_id: Random from 50 technicians,
    service_id: Random from 20 services,
    start_time: Random date in 2 years,
    end_time: start_time + service duration,
    status: 60% COMPLETED, 20% CANCELLED, 20% CONFIRMED,
    final_price: Service price,
    created_at: start_time
  }
  
  Resources assigned:
    ├─ ROOM: Mandatory (1 random room)
    ├─ DEVICE: Mandatory (1 random device)
    └─ VIP_ROOM: Optional (50% chance)
```

#### D. Key Optimization: Batch Processing

```
Why batch processing?
  ├─ 500k inserts in ONE transaction = memory overflow
  ├─ Batches of 50k = safer memory usage
  └─ 10 batches with COMMIT between = safe execution

Disabled triggers during bulk insert:
  ├─ Turns OFF all appointment triggers temporarily
  └─ Speeds up insertion (no trigger overhead)
  └─ Re-enables after completion

Performance optimization:
  SET synchronous_commit = OFF;  ← Don't wait for disk
  SET work_mem = '64MB';         ← More memory for sorting/joining
```

### Category 4: ABSENCE REQUESTS (50-200 records)

#### A. Purpose

**Create time-off requests for each technician** to simulate realistic scheduling.

```
For each of 50 technicians:
  ├─ Randomly generates 1-20 absence requests
  ├─ Each request: 1-4 days off
  ├─ Reason: "Sick Leave", "Vacation", "Personal Matter"
  ├─ Status: 50% "APPROVED", 50% "PENDING"
  └─ Only creates if no conflicting appointments
```

#### B. How It's Created

```sql
DO $$
DECLARE
  v_tech_id INT;
  v_start_date TIMESTAMP;
  v_end_date TIMESTAMP;
BEGIN
  FOREACH v_tech_id IN ARRAY v_tech_ids LOOP
    FOR j IN 1..20 LOOP  -- Try up to 20 times per tech
      
      -- Generate random dates
      v_start_date := random_past_date;
      v_end_date := v_start_date + (1-4 days);
      
      -- Check for conflicts
      SELECT EXISTS (
        SELECT 1 FROM appointment
        WHERE technician_id = v_tech_id
        AND status != 'CANCELLED'
        AND appointment overlaps absence period
      ) INTO v_has_conflict;
      
      -- Only insert if no conflict
      IF NOT v_has_conflict THEN
        INSERT INTO absence_request (...)
        VALUES (v_tech_id, v_start_date, v_end_date, ...);
      END IF;
      
    END LOOP;
  END LOOP;
END $$;
```

---

## PROCEDURE EXPLANATION

### PROCEDURE: `seed_appointments(p_batch_size INT)`

#### A. Purpose

**Insert a batch of appointment records efficiently** without overwhelming the database.

Real-world example:

```
Inserting 500,000 records all at once:
  ❌ Would use too much memory
  ❌ Single transaction too big
  ❌ Takes hours

With batching:
  ✅ 10 batches of 50,000
  ✅ Each transaction manageable
  ✅ Takes minutes instead of hours
```

#### B. How It's Activated

**Called directly by migration script**, 10 times with batch size.

```
Activation:
├─ CALL seed_appointments(50000);  ← Inserts 50k records
├─ ... (repeated 10 times)
└─ Total: 500k records inserted
```

#### C. Activation Code

```sql
-- Before bulk insert: Disable triggers for speed
ALTER TABLE appointment DISABLE TRIGGER ALL;

-- Execute 10 batches
CALL seed_appointments(50000); COMMIT;  -- Records 1-50k
CALL seed_appointments(50000); COMMIT;  -- Records 50k-100k
CALL seed_appointments(50000); COMMIT;  -- Records 100k-150k
CALL seed_appointments(50000); COMMIT;  -- Records 150k-200k
CALL seed_appointments(50000); COMMIT;  -- Records 200k-250k
CALL seed_appointments(50000); COMMIT;  -- Records 250k-300k
CALL seed_appointments(50000); COMMIT;  -- Records 300k-350k
CALL seed_appointments(50000); COMMIT;  -- Records 350k-400k
CALL seed_appointments(50000); COMMIT;  -- Records 400k-450k
CALL seed_appointments(50000); COMMIT;  -- Records 450k-500k

-- After bulk insert: Re-enable triggers
ALTER TABLE appointment ENABLE TRIGGER ALL;
```

#### D. Main Logic (Simplified)

```
PROCEDURE: seed_appointments(p_batch_size)

FOR each of p_batch_size iterations:
  
  STEP 1: Randomly select data
    ├─ Customer: Random from 20,000 customers
    ├─ Technician: Random from 50 technicians
    └─ Service: Random from 20 services
  
  STEP 2: Generate time
    ├─ start_time: Random date within 2 years (2025-2026)
    ├─ end_time: start_time + service.duration_minutes
    └─ created_at: Same as start_time
  
  STEP 3: Generate status
    ├─ 60% chance: COMPLETED (past appointments)
    ├─ 20% chance: CANCELLED (cancelled appointments)
    └─ 20% chance: CONFIRMED (future appointments)
  
  STEP 4: Insert appointment
    ├─ appointment_id: Auto-generated
    ├─ final_price: Service price
    ├─ Other fields populated
    └─ RETURNING appointment_id
  
  STEP 5: Assign resources
    ├─ ROOM: 1 mandatory room assigned
    ├─ DEVICE: 1 mandatory device assigned
    └─ VIP_ROOM: 50% chance to assign one
    
END FOR
```

#### E. Effect on Data

| Reads From | Writes To | Effect |
|---|---|---|
| customer, technician, services, resources tables | appointment, appointment_resource tables | Creates appointment records with resource assignments |

---

## HOW BACKEND USES THIS DATA

### What This File Actually Does

```
This is NOT backend code. It's DATABASE SETUP.

Execution timeline:
  1. Database created (V1-V5 migrations run)
  2. V6 seed script executes (ONE TIME ONLY!)
  3. Database now has 520,000 records
  4. Backend can now test/run with realistic data
```

### Backend Does NOT Interact With V6

```java
// Backend DOES NOT call V6 functions
// V6 runs automatically during database initialization

// What backend DOES do:
@Service
public class AppointmentService {
    
    public List<Appointment> getUpcomingAppointments() {
        // Returns appointments created by V6 seed data
        return appointmentRepository.findUpcoming();
    }
    
    public Appointment createAppointment(AppointmentRequest req) {
        // New appointments after V6 has run
        return appointmentRepository.save(new Appointment(...));
    }
}

// Backend uses the DATA created by V6, but doesn't call V6 code
```

### When Does V6 Execute?

```
Flyway migration process:

1. Application starts
2. Flyway checks database version
3. Flyway executes migrations:
   ├─ V1__init_schema.sql (creates tables)
   ├─ V2__add_booking_logic.sql (adds functions/triggers)
   ├─ V3__create_absence_conflict_trigger.sql (more logic)
   ├─ V4__create_revenue_func.sql (reporting)
   ├─ V5__create_reporting_views.sql (views)
   └─ V6__seed_data.sql ← RUNS HERE (inserts 500k records)
4. Database is ready with data
5. Application starts serving requests
```

---

## BUSINESS RULES

### Rule 1: Realistic Customer Growth

```
Rule: Customers have created_at dates spread over 2 years (0-730 days ago)

Why:
  ├─ Simulates real customer acquisition
  ├─ Some customers are old (loyal), some are new
  └─ Useful for testing retention metrics

Example:
  Customer 1: created_at = 2024-01-15 (old customer)
  Customer 2: created_at = 2025-12-20 (new customer)
  Customer 3: created_at = 2025-06-10 (mid-tenure)
```

### Rule 2: Appointments Distributed Across Time

```
Rule: 500k appointments spread across 2 years (2025-2027)

Why:
  ├─ Simulates active spa business
  ├─ Tests performance with large datasets
  ├─ Tests date filtering (by day/month/year)
  └─ Tests reporting over time periods

Example:
  Appointment 1: 2025-01-10 (oldest)
  Appointment 250k: 2026-01-10 (middle)
  Appointment 500k: 2027-01-10 (newest)
```

### Rule 3: Realistic Appointment Statuses

```
Rule: Appointment status distribution:
  ├─ 60% COMPLETED (service happened, payment received)
  ├─ 20% CANCELLED (customer cancelled)
  └─ 20% CONFIRMED (future appointment, not yet completed)

Why:
  ├─ Reflects real spa patterns
  ├─ Tests reporting on different statuses
  ├─ Tests revenue calculation (only COMPLETED counted)
  └─ Tests absence/resource conflicts

Example (100 appointments):
  ├─ 60 COMPLETED (60 * $price = revenue)
  ├─ 20 CANCELLED (no revenue)
  └─ 20 CONFIRMED (future, no revenue yet)
```

### Rule 4: Every Service Needs Resources

```
Rule: Each appointment must have:
  ├─ 1 ROOM (mandatory)
  ├─ 1 DEVICE (mandatory)
  └─ 1 VIP_ROOM (50% optional)

Why:
  ├─ Realistically, services need facilities
  ├─ Tests resource availability/conflicts
  ├─ Tests booking system's resource allocation
  └─ Ensures no unassigned resources

Example:
  Appointment with Service="Massage":
    ├─ Assigned Room 5
    ├─ Assigned Device 3
    └─ Assigned VIP Room 2 (50% chance)
```

### Rule 5: Technicians Know Subset of Services

```
Rule: Each technician can provide ~50% of services

Why:
  ├─ Realistic (not all techs know all services)
  ├─ Tests tech availability/scheduling
  ├─ Tests booking validation (tech must know service)
  └─ Adds complexity to resource allocation

Example:
  Tech 1 knows: Services 1, 3, 5, 7, ... (50% of 20)
  Tech 2 knows: Services 2, 4, 6, 8, ... (50% of 20)
  Tech 3 knows: Services 1, 2, 5, 9, ... (50% of 20)
```

### Rule 6: Absence Requests Avoid Appointment Conflicts

```
Rule: Absence requests only created if NO appointments conflict

Why:
  ├─ Tests V3 absence validation logic
  ├─ Ensures data consistency
  ├─ Simulates real scheduling constraints
  └─ Tests conflict detection

Example:
  Tech has appointments: Jan 10, 15, 20
  
  Absence request Jan 5-8: ✅ ALLOWED (no conflict)
  Absence request Jan 12-17: ❌ SKIPPED (conflicts with Jan 15)
  Absence request Jan 25-28: ✅ ALLOWED (no conflict)
```

### Rule 7: Sequence Reset for Auto-Increment

```
Rule: Primary key sequences reset to MAX(id) in database

Why:
  ├─ New records get correct IDs
  ├─ Avoids ID conflicts
  ├─ Ensures IDs are continuous
  └─ Prepares database for new records

Example:
  After seeding:
    ├─ appointment_appointment_id_seq = 500,000
    └─ Next new appointment gets ID 500,001
```

---

## REAL-WORLD SCENARIOS

### Scenario 1: Development Team Sets Up Local Database

```
REAL WORLD:
  Developer: "I need to test the booking system"
  
  Steps:
  1. Clone repo
  2. Run: mvn spring-boot:run (or gradle bootRun)
  3. Application starts

BEHIND THE SCENES:
  1. Spring Boot initializes database
  2. Flyway migration framework runs:
     ├─ V1: Creates empty tables
     ├─ V2-V5: Creates functions/triggers
     └─ V6: Inserts 500,000 test appointments ← AUTOMATIC!
  
  3. Database now ready with realistic data:
     ├─ 20,000 customers with 2-year history
     ├─ 500,000 appointments across 2 years
     ├─ 50 technicians with their schedules
     ├─ 50 rooms + devices available
     └─ Realistic absence requests

  4. Developer can immediately test:
     ├─ Booking new appointment
     ├─ Viewing past appointments
     ├─ Checking technician availability
     ├─ Testing reporting dashboards
     └─ Load testing with real data

RESULT:
  "Great! Database is ready. Let me test the booking API"
  
Backend now has realistic data to work with ✓
```

### Scenario 2: QA Testing Dashboard Performance

```
REAL WORLD:
  QA Engineer: "Let me test dashboard with real data"
  
WHAT DATA EXISTS (from V6):
  ├─ 500,000 appointments total
  ├─ Revenue calculated from COMPLETED appointments
  └─ Dashboard queries return millions of records

QUERIES EXECUTED BY DASHBOARD:
  1. "Show me appointments for Dec 2025"
     SELECT * FROM appointment WHERE start_time IN Dec 2025
     Result: ~42,000 appointments (500k / 12 months)
  
  2. "Show me revenue for 2025"
     SELECT SUM(final_price) FROM appointment 
     WHERE status='COMPLETED' AND year=2025
     Result: $15,000,000 (average)
  
  3. "Show customer trends"
     SELECT COUNT(*) FROM users WHERE role='CUSTOMER'
                               AND created_at >= date
     Result: 20,000 customers

PERFORMANCE TEST:
  QA notes: "Dashboard loads in 200ms with 500k records"
  
Good performance baseline established ✓
```

### Scenario 3: New Developer Onboarding

```
REAL WORLD:
  New Developer: "I need to understand how the system works"
  
LEARNING PROCESS:
  1. Clone repo
  2. Run app (V6 seed data loads automatically)
  3. Open admin dashboard
  4. Sees:
     ├─ Calendar with hundreds of appointments
     ├─ Customer list with 20,000 names
     ├─ Revenue reports showing data
     ├─ Technician schedules
     └─ Resource allocation maps
  
  5. Explores database:
     SELECT * FROM appointment LIMIT 10;
     ├─ Real appointment structure
     ├─ Real relationships
     ├─ Real business logic
  
  6. Understands:
     ├─ How appointments connect customers + techs
     ├─ How resources are allocated
     ├─ How revenue is tracked
     ├─ How absence affects scheduling

RESULT:
  "Now I understand! The system is making sense"
  
New developer productivity increased ✓
```

### Scenario 4: Demo to Client

```
REAL WORLD:
  Manager: "Let me show the client what our system looks like"
  
SETUP:
  1. Run application with V6 seed data
  2. Database has realistic data
  3. Application ready for demo
  
CLIENT DEMO:
  Manager shows:
    ├─ Dashboard: "See 500k appointments tracked"
    ├─ Calendar: "See technician schedules with real data"
    ├─ Revenue: "Reports show $X in revenue"
    ├─ Customers: "20,000 customers using system"
    └─ Scheduling: "Complex booking with resources"
  
CLIENT IMPRESSION:
  "This looks solid! I can see real data"
  
Not a dummy empty system, but realistic ✓
```

---

## END-TO-END WORKFLOW

### Workflow 1: Complete Database Setup (Initialization)

```
┌─────────────────────────────────────────────────────────────┐
│ DEVELOPER STARTS APPLICATION                                │
├─────────────────────────────────────────────────────────────┤
│ mvn spring-boot:run                                         │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ SPRING BOOT INITIALIZES                                     │
├─────────────────────────────────────────────────────────────┤
│ 1. Connect to PostgreSQL database                           │
│ 2. Check database version                                   │
│ 3. Flyway migration framework starts                        │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ FLYWAY EXECUTES MIGRATIONS IN ORDER                         │
├─────────────────────────────────────────────────────────────┤
│ Migration V1: Create all tables (users, appointment, etc.)  │
│   └─ Schema ready, all tables empty                         │
│                                                             │
│ Migration V2: Add booking logic (triggers, functions)       │
│   └─ Business rules installed                              │
│                                                             │
│ Migration V3: Add absence validation                        │
│   └─ Time-off constraints installed                        │
│                                                             │
│ Migration V4: Add revenue function                          │
│   └─ Reporting capability installed                        │
│                                                             │
│ Migration V5: Create dashboard views                        │
│   └─ Query optimization installed                          │
│                                                             │
│ Migration V6: SEED DATA ← WE ARE HERE                       │
│   └─ Populate with test data...                            │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ V6 SEEDING BEGINS                                           │
├─────────────────────────────────────────────────────────────┤
│ STEP 1: Performance optimization                           │
│   ├─ SET synchronous_commit = OFF (faster writes)          │
│   └─ SET work_mem = '64MB' (more memory)                   │
│                                                             │
│ STEP 2: Create static data                                  │
│   ├─ INSERT 20 services (massage, haircut, etc.)           │
│   ├─ INSERT 80 resources (50 rooms + 10 VIP + 20 devices) │
│   └─ INSERT resource requirements (room + device needed)   │
│                                                             │
│ STEP 3: Create users (20,050 total)                        │
│   ├─ INSERT 50 technicians (techs with email)             │
│   ├─ INSERT 20,000 customers (customers with history)     │
│   └─ Link technicians to services they know                │
│                                                             │
│ STEP 4: Create appointments (500,000 total)                │
│   ├─ Disable triggers (for speed)                          │
│   ├─ CALL seed_appointments(50000) × 10 times             │
│   │  └─ Total: 500,000 appointments inserted               │
│   ├─ Re-enable triggers                                    │
│   └─ COMMIT final data                                     │
│                                                             │
│ STEP 5: Create absence requests                            │
│   ├─ FOR each technician (50 total)                        │
│   │  ├─ Try to create 1-20 absence requests               │
│   │  ├─ Skip if conflicts with appointments               │
│   │  └─ Result: 50-200 absence requests                   │
│                                                             │
│ STEP 6: Reset sequences                                    │
│   ├─ Set appointment_id sequence to 500,000               │
│   ├─ Set user_id sequence to 20,050                       │
│   └─ Next inserts get correct IDs                          │
│                                                             │
│ STEP 7: Analyze statistics                                 │
│   ├─ ANALYZE appointment (for query planner)              │
│   ├─ ANALYZE users (for query planner)                    │
│   └─ Database optimizer prepares for queries               │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ DATABASE NOW READY                                          │
├─────────────────────────────────────────────────────────────┤
│ Data present:                                               │
│   ├─ 50 technicians with work history                      │
│   ├─ 20,000 customers with account creation dates          │
│   ├─ 500,000 appointments (past, present, future)          │
│   ├─ Resources allocated to appointments                   │
│   ├─ 50-200 absence requests for techs                     │
│   └─ Realistic pricing and durations                       │
│                                                             │
│ Time taken: ~5-10 minutes (depending on hardware)          │
│ Database ready for: Development, testing, demos             │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ APPLICATION STARTS SUCCESSFULLY                             │
├─────────────────────────────────────────────────────────────┤
│ Backend application now online                             │
│ Database contains realistic data                            │
│ Developers can:                                             │
│   ├─ Test booking functionality                           │
│   ├─ View appointment history                             │
│   ├─ Check technician schedules                           │
│   ├─ Test reporting dashboards                            │
│   ├─ Load test with 500k records                          │
│   └─ Demonstrate system to stakeholders                   │
│                                                             │
│ API endpoints now return real data!                         │
│ Frontend can display actual appointments!                   │
│ Reporting shows legitimate metrics!                         │
└─────────────────────────────────────────────────────────────┘
```

### Workflow 2: Developer Booking New Appointment

```
┌─────────────────────────────────────────────────────────────┐
│ AFTER DATABASE SETUP WITH V6 DATA                           │
├─────────────────────────────────────────────────────────────┤
│ Database has 500,000 existing appointments                  │
│ Now developer creates a NEW one                            │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ BACKEND RECEIVES BOOKING REQUEST                            │
├─────────────────────────────────────────────────────────────┤
│ POST /api/appointments                                      │
│ {                                                            │
│   customer_id: 100,                                         │
│   technician_id: 5,                                         │
│   service_id: 3,                                            │
│   start_time: "2026-01-15 10:00"                           │
│ }                                                            │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ BACKEND INSERTS APPOINTMENT                                 │
├─────────────────────────────────────────────────────────────┤
│ AppointmentService.createAppointment(request):             │
│   INSERT INTO appointment (...)                             │
│   VALUES (customer_id=100, tech_id=5, ...)                 │
│   RETURNING appointment_id = 500,001                        │
│                                                             │
│ (Note: ID 500,001 because sequence was reset to 500,000)   │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ DATABASE TRIGGERS FIRE (V2-V3 LOGIC)                        │
├─────────────────────────────────────────────────────────────┤
│ V2 Triggers:                                                │
│   ├─ Validate appointment details                          │
│   ├─ Assign resources automatically                        │
│   └─ Set default status                                    │
│                                                             │
│ V3 Triggers:                                                │
│   ├─ Check for absence conflicts                           │
│   ├─ Check for technician availability                     │
│   └─ Validate business rules                               │
│                                                             │
│ Result: Appointment 500,001 created successfully           │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ BACKEND RESPONDS                                            │
├─────────────────────────────────────────────────────────────┤
│ HTTP 201 Created                                            │
│ {                                                            │
│   appointment_id: 500,001,                                  │
│   customer_id: 100,                                         │
│   technician_id: 5,                                         │
│   service_id: 3,                                            │
│   start_time: "2026-01-15 10:00",                          │
│   status: "CONFIRMED"                                       │
│ }                                                            │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ RESULT                                                      │
├─────────────────────────────────────────────────────────────┤
│ Database now has 500,001 appointments                       │
│ V6 created 500,000 seed data                                │
│ Developer just added 1 new appointment                      │
│ Sequence reset ensures no ID collisions ✓                   │
└─────────────────────────────────────────────────────────────┘
```

---

## FINAL MENTAL MODEL

### In Short...

**V6__seed_data.sql is NOT business logic—it's database initialization.** It populates an empty database with **500,000 realistic appointment records** plus supporting data (customers, technicians, services, resources, absences) so that developers can test and demo the system with real-world scenarios.

### Key Purposes

| Purpose | Details |
|---------|---------|
| **Development** | Developers have data to code against |
| **Testing** | QA has realistic scenarios to test |
| **Performance** | Large dataset (500k) for load/stress testing |
| **Demos** | Shows client a working system with real data |
| **Learning** | New team members understand real data structure |

### What V6 Actually Is

```
V6 is like: "Opening a store with inventory"

Without V6 (empty store):
  ├─ Shelves created (V1)
  ├─ Cash registers installed (V2-V5)
  ├─ But: NO PRODUCTS!
  └─ Can't test if checkout works

With V6 (stocked store):
  ├─ Shelves created
  ├─ Cash registers installed
  ├─ 500,000 products on shelves
  └─ Ready to test checkout! ✓
```

### Data Quality

```
Is V6 data "real"?
  ├─ Names: Fake (Cust 1, Tech 1, etc.)
  ├─ Emails: Fake (cust1@mail.com)
  ├─ Passwords: Fake ('$2a$10$Fake')
  └─ Dates: Realistic (spread across 2 years)
  └─ Prices: Realistic (random $50-$550)
  └─ Business logic: Real (follows constraints)

Sufficient for testing and demos? YES ✓
```

### Batch Processing Importance

```
Why 10 batches of 50,000 instead of 1 batch of 500,000?

Without batching (one big transaction):
  ├─ Loads all 500k records into memory
  ├─ Database locks table for entire time
  ├─ Takes 30+ minutes
  ├─ Risk of out-of-memory
  └─ Could crash

With batching (10 × 50k):
  ├─ Each batch: manageable memory
  ├─ Each COMMIT: frees memory
  ├─ Parallel-safe execution
  ├─ Takes 5-10 minutes
  └─ Reliable, stable ✓
```

### Trigger Management During Seeding

```
Triggers DISABLED during bulk insert:

Why?
  ├─ V2-V3 triggers validate each appointment
  ├─ 500k trigger executions = massive overhead
  ├─ Would take hours with triggers enabled
  ├─ Unnecessary for seed data (we control it)

Process:
  1. ALTER TABLE appointment DISABLE TRIGGER ALL;
  2. CALL seed_appointments(50000) × 10
  3. ALTER TABLE appointment ENABLE TRIGGER ALL;

Result: Fast seeding, then triggers re-enabled for real use ✓
```

---

## QUICK REFERENCE

### Data Volumes

| Entity | Count | Purpose |
|--------|-------|---------|
| Services | 20 | Different spa/salon services |
| Resources | 80 | Rooms, devices, VIP areas |
| Technicians | 50 | Staff members |
| Customers | 20,000 | People who book appointments |
| Appointments | 500,000 | Booking records (2-year history) |
| Absence Requests | 50-200 | Staff time-off requests |
| **TOTAL** | **~520,000 records** | **Realistic test dataset** |

### Status Distribution (500k Appointments)

| Status | Count | Meaning |
|--------|-------|---------|
| COMPLETED | 300,000 (60%) | Service done, payment received |
| CANCELLED | 100,000 (20%) | Booking cancelled |
| CONFIRMED | 100,000 (20%) | Future booking, not completed |

### Resource Allocation (Every Appointment)

| Resource Type | Requirement | Count |
|---|---|---|
| ROOM | Mandatory | 1 per appointment |
| DEVICE | Mandatory | 1 per appointment |
| VIP_ROOM | Optional | ~50% of appointments |

### Execution Timeline

| Phase | Duration | Action |
|-------|----------|--------|
| V1-V5 Migrations | 1-2 min | Schema + functions |
| Static Data | <1 sec | Services, resources |
| Users | 30 sec | 50 techs + 20k customers |
| Appointments | 3-5 min | 500k records in 10 batches |
| Absence Requests | 30 sec | 50-200 requests |
| Cleanup | <1 sec | Sequence reset, stats |
| **Total** | **~5-10 min** | **Database ready** |

---

## Quick Flow Diagram

```
Application starts
         ↓
Spring Boot initialization
         ↓
Flyway migration framework detects pending migrations
         ↓
Run V1-V5 (schema + logic)
         ↓
Run V6__seed_data.sql
         ├─ Insert 20 services
         ├─ Insert 80 resources
         ├─ Insert 50 technicians + 20,000 customers
         ├─ Disable triggers (for speed)
         ├─ Insert 500,000 appointments in 10 batches
         ├─ Re-enable triggers
         ├─ Insert 50-200 absence requests
         ├─ Reset ID sequences
         └─ Analyze tables for performance
         ↓
All migrations complete
         ↓
Database ready with 500k+ records
         ↓
Application starts successfully
         ↓
Developers can test/demo with realistic data ✓
```

---

**Document:** V6__seed_data.sql Explanation  
**Purpose:** Understanding database initialization and test data  
**Audience:** Developers, QA, new team members  
**Language:** Workflow-focused explanation  
**Note:** V6 is NOT business logic—it's setup/initialization code
