# JPA Execution Traces: Functions 11-15

**Project:** AuraControl Spa Management System  
**Scope:** CRUD operations with PURE SQL execution  
**Date:** December 30, 2025

---

## FUNCTION 11: ResourceRepository.findBusyResourceIds()

**Function Name:** findBusyResourceIds(LocalDateTime startTime, LocalDateTime endTime)  
**Layer:** Repository  
**File Path:** Backend/auracontrol/src/main/java/com/example/auracontrol/booking/repository/ResourceRepository.java  
**Class:** ResourceRepository  
**Triggered API:** POST /api/booking (indirectly)  
**HTTP Method + URL:** POST /api/booking  
**CRUD Type:** READ (complex JOIN query)

### 1) Execution Path

```
HTTP POST /api/booking (JSON: BookingRequest)
    ↓
BookingController.createBooking(BookingRequest)
    ↓
AppointmentService.createAppointment(request)
    ↓
resourceRepository.findBusyResourceIds(startTime, endTime)  ← HERE
    ↓
Spring Data JPA executes @Query
    ↓
PostgreSQL executes complex JOIN query
    ├─ JOIN appointment_resource on appointment
    ├─ Filter by status != 'CANCELLED'
    ├─ Filter by time overlap
    └─ SELECT only resource_id
    ↓
ResultSet mapped to List<Integer>
    ↓
Service filters out busy resources
    ↓
Continues with available resource allocation
```

### 2) Critical Code Snippet

```java
// ResourceRepository.java (Line 18-21)
@Query("SELECT ar.id.resourceId FROM AppointmentResource ar " +
        "JOIN ar.appointment a " +
        "WHERE a.status <> 'CANCELLED' " +
        "AND a.startTime < :endTime AND a.endTime > :startTime")
List<Integer> findBusyResourceIds(
    @Param("startTime") LocalDateTime startTime,
    @Param("endTime") LocalDateTime endTime
);

// AppointmentService.java (Line ~130)
List<Integer> busyIds = resourceRepository.findBusyResourceIds(startTime, endTime);

if (busyIds.isEmpty()) {
    busyIds.add(-1);  // Prevent empty IN clause
}

for (ServiceResourceRequirement req : requirements) {
    Resource foundResource = resourceRepository
            .findFirstAvailableByType(requiredType, busyIds)
            .orElseThrow(...);
    
    busyIds.add(foundResource.getResourceId());
}
```

### 3) SQL Execution Details

**SQL Type:** SELECT (complex JOIN)  
**Target Tables:** appointment_resource, appointment  

**SQL Generated:**
```sql
SELECT ar.resource_id 
FROM appointment_resource ar
JOIN appointment a ON ar.appointment_id = a.appointment_id
WHERE a.status != 'CANCELLED'
  AND a.start_time < ?
  AND a.end_time > ?
```

**Parameter Binding:**
- endTime: TIMESTAMP (WHERE a.start_time < :endTime)
- startTime: TIMESTAMP (WHERE a.end_time > :startTime)
- Time overlap logic: appointment overlaps if (start < query_end AND end > query_start)

**Execution Flow:**
1. Service calls resourceRepository.findBusyResourceIds()
2. @Query with JPQL detected
3. Hibernate translates to native SQL
4. PreparedStatement created with 2 parameters
5. Binds: startTime and endTime
6. Executes JOIN:
   - FROM appointment_resource ar (composite key table)
   - JOIN appointment a ON FK
   - WHERE a.status != 'CANCELLED' (filter cancelled)
   - AND time overlap logic (4D range check)
7. SELECT only resource_id (projection)
8. PostgreSQL returns result set (0 to N rows)
9. Hibernate maps each row to Integer
10. Returns List<Integer>

### 4) Java Object ↔ PostgreSQL Row Mapping

**Java Object:** List<Integer> (not entity)  
**Mapping Type:** Projection query (single column mapping)

**Column → Field Mapping:**
```
appointment_resource.resource_id  → Integer (autoboxed)
```

**Mapping Mechanism:**
- Hibernate detects SELECT ar.id.resourceId (property projection)
- ar.id.resourceId extracts the resourceId field from composite key
- Each row becomes one Integer
- Returns List<Integer>

### 5) PostgreSQL Trigger Interaction

**Trigger Exists:** NONE triggered (SELECT only)  
**Reason:** No DML (INSERT/UPDATE/DELETE), triggers don't fire

### 6) Transaction & Exception Flow

**Transaction Start:** @Transactional on AppointmentService.createAppointment()  
**Scope:** SELECT within transaction (read-only)

**Success Path:**
1. Query executes
2. ResultSet returned (may be empty)
3. List<Integer> populated (or empty)
4. Service continues with resource allocation
5. No exception

**Failure Paths:**

**Scenario A: Empty result (no busy resources)**
```
Query executes
    ↓
No matching appointments found
    ↓
Empty ResultSet
    ↓
List<Integer> busyIds = [] (empty list)
    ↓
Service adds -1 as placeholder (prevent SQL error in IN clause)
    ↓
busyIds = [-1]
    ↓
Continues (no error)
```

**Scenario B: Database query timeout**
```
Complex JOIN takes too long
    ↓
JDBC timeout (default 30 seconds)
    ↓
SQLException: Query timeout
    ↓
Hibernate wraps as PersistenceException
    ↓
Spring wraps as DataAccessException
    ↓
@Transactional: ROLLBACK
    ↓
HTTP 504 Gateway Timeout
```

**Scenario C: JOIN table missing FK reference**
```
FK constraint violation during JOIN
    ↓
PostgreSQL raises FK error
    ↓
Exception propagates
    ↓
HTTP 400 Bad Request
```

### 7) Final Outcome

**Success - Resources found:**
```
List<Integer> busyIds = [3, 5, 8]
```
- Returns IDs of busy resources
- Service excludes these from available list
- HTTP 200 OK (from overall booking flow)

**Success - No busy resources:**
```
List<Integer> busyIds = [] (empty)
```
- No resources in use during time slot
- Service adds -1 placeholder
- All resources potentially available
- HTTP 200 OK

**Success - Partial busy:**
```
List<Integer> busyIds = [1, 4]
```
- Resources 1 and 4 are busy
- Resources 2, 3, 5, 6, etc. available
- HTTP 200 OK

**Failure - Timeout:**
```json
{
  "error": "Query timeout finding available resources",
  "status": 504
}
```
- HTTP 504 Gateway Timeout

---

## FUNCTION 12: ResourceRepository.findAvailableResources()

**Function Name:** findAvailableResources(String type, Collection<Integer> busyIds, Pageable pageable)  
**Layer:** Repository  
**File Path:** Backend/auracontrol/src/main/java/com/example/auracontrol/booking/repository/ResourceRepository.java  
**Class:** ResourceRepository  
**Triggered API:** POST /api/booking (indirectly)  
**HTTP Method + URL:** POST /api/booking  
**CRUD Type:** READ (filtered list query)

### 1) Execution Path

```
HTTP POST /api/booking
    ↓
BookingController.createBooking(BookingRequest)
    ↓
AppointmentService.createAppointment(request)
    ↓
For each required resource type:
    ├─ Get busy IDs: findBusyResourceIds()
    ↓
    resourceRepository.findAvailableResources(type, busyIds, pageable)  ← HERE
    ↓
Spring Data JPA executes @Query with IN clause
    ↓
PostgreSQL filters:
    ├─ WHERE type = ?
    ├─ WHERE NOT IN (busy IDs)
    ├─ WHERE is_deleted = false
    └─ LIMIT 1 (first available)
    ↓
ResultSet mapped to List<Resource>
    ↓
Service takes first from list
    ↓
Allocates resource to appointment
```

### 2) Critical Code Snippet

```java
// ResourceRepository.java (Line 24-29)
@Query("SELECT r FROM Resource r " +
        "WHERE r.type = :type " +
        "AND r.resourceId NOT IN :busyIds")
List<Resource> findAvailableResources(
    @Param("type") String type,
    @Param("busyIds") Collection<Integer> busyIds,
    Pageable pageable
);

// AppointmentService.java (Line ~135-145)
for (ServiceResourceRequirement req : requirements) {
    String requiredType = req.getResourceType();
    
    Resource foundResource = resourceRepository
            .findFirstAvailableByType(requiredType, busyIds)
            .orElseThrow(() ->
                    new ResourceNotFoundException(
                        "Hiện tại không đủ tài nguyên loại: " + requiredType
                    )
            );
    
    busyIds.add(foundResource.getResourceId());
}
```

### 3) SQL Execution Details

**SQL Type:** SELECT (filtered IN clause)  
**Target Table:** resources  

**SQL Generated:**
```sql
SELECT r.* FROM resources r
WHERE r.type = ?
  AND r.resource_id NOT IN (?, ?, ?, ...)
  AND r.is_deleted = false
LIMIT 1
```

**Parameter Binding:**
- type: VARCHAR (resource type: 'ROOM', 'DEVICE', etc.)
- busyIds: Collection<Integer> (dynamic IN clause)
  - Each ID bound separately
  - If empty: uses empty IN clause or placeholder (-1)

**Execution Flow:**
1. Service calls findAvailableResources(type, busyIds, pageable)
2. @Query with JPQL detected
3. Hibernate translates to native SQL
4. Dynamic IN clause generated:
   - If busyIds = [3, 5, 8]: NOT IN (3, 5, 8)
   - If busyIds = [-1]: NOT IN (-1) (placeholder, no real resource)
5. PreparedStatement created
6. Binds: type = ?, resource_id NOT IN (...)
7. Executes:
   - FROM resources table
   - WHERE type = ? (filter by equipment type)
   - WHERE resource_id NOT IN (...) (exclude busy)
   - WHERE is_deleted = false (exclude soft-deleted)
   - LIMIT 1 (first available)
8. Returns List<Resource> (0 or 1 element with LIMIT 1)

### 4) Java Object ↔ PostgreSQL Row Mapping

**Java Object:** Resource entity  
**Mapping Type:** Entity auto-mapping

**Column → Field Mapping:**
```
resources.resource_id  → Resource.resourceId (Integer, @Id)
resources.name         → Resource.name (String)
resources.type         → Resource.type (String)
resources.is_deleted   → Resource.isDeleted (Boolean)
```

**Mapping Mechanism:**
- Hibernate reads @Entity annotation on Resource
- Each column mapped to field via @Column annotations
- ResultSet row converted to Resource instance
- Returns List<Resource>

### 5) PostgreSQL Trigger Interaction

**Trigger Exists:** NONE (SELECT only)

### 6) Transaction & Exception Flow

**Transaction Start:** @Transactional on AppointmentService.createAppointment()  
**Scope:** SELECT within transaction

**Success Path:**
1. Query executes
2. ResultSet returned
3. Resource entity populated
4. Service takes first resource
5. Adds resourceId to busyIds for next iteration
6. Continues

**Failure Paths:**

**Scenario A: No available resources**
```
Query executes
    ↓
WHERE type = 'ROOM' AND resource_id NOT IN (3,5,8) AND is_deleted = false
    ↓
No matching rows (all rooms busy or deleted)
    ↓
Empty List<Resource> returned
    ↓
Service calls .orElseThrow()
    ↓
throw ResourceNotFoundException("No available resource of type: ROOM")
    ↓
@Transactional: ROLLBACK
    ↓
HTTP 400 Bad Request
```

**Scenario B: IN clause too large (unlikely)**
```
busyIds Collection has 10,000+ items
    ↓
IN clause becomes massive
    ↓
PostgreSQL query planning takes time
    ↓
Performance degradation but not error
```

### 7) Final Outcome

**Success - Resource found:**
```java
Resource foundResource = Resource(
    resourceId: 7,
    name: "Room A",
    type: "ROOM",
    isDeleted: false
)
```
- Resource allocated to appointment
- Added to busyIds for next iteration
- HTTP 200 OK (from overall booking)

**Success - No available resources:**
```
List<Resource> = [] (empty)
```
- .orElseThrow() triggered
- HTTP 400 Bad Request: "No available resource of type: ROOM"

---

## FUNCTION 13: AppointmentRepository.findAppointmentsForAdmin()

**Function Name:** findAppointmentsForAdmin(String keyword, String status, Pageable pageable)  
**Layer:** Repository  
**File Path:** Backend/auracontrol/src/main/java/com/example/auracontrol/booking/repository/AppointmentRepository.java  
**Class:** AppointmentRepository  
**Triggered API:** GET /api/admin/appointments  
**HTTP Method + URL:** GET /api/admin/appointments?keyword=&status=&page=0&size=20  
**CRUD Type:** READ (paginated search query)

### 1) Execution Path

```
HTTP GET /api/admin/appointments?keyword=John&status=CONFIRMED&page=0&size=20
    ↓
AdminAppointmentController.getAppointments(keyword, status, pageable)
    ↓
AppointmentService.getAppointmentsForAdmin(keyword, status, pageable)
    ↓
appointmentRepository.findAppointmentsForAdmin(keyword, status, pageable)  ← HERE
    ↓
Spring Data JPA executes @Query with dynamic parameters
    ↓
PostgreSQL executes paginated search:
    ├─ WHERE status = ? OR status IS NULL
    ├─ WHERE name/technician/service LIKE keyword
    ├─ ORDER BY startTime DESC
    └─ LIMIT 20 OFFSET 0
    ↓
ResultSet mapped to Page<Appointment>
    ↓
Service returns paginated response to Controller
```

### 2) Critical Code Snippet

```java
// AppointmentRepository.java (Line 90-100)
@Query("SELECT a FROM Appointment a " +
        "WHERE (:status IS NULL OR a.status = :status) " +
        "AND (:keyword IS NULL OR :keyword = '' OR " +
        "LOWER(a.customer.user.name) LIKE LOWER(CONCAT('%', :keyword, '%')) OR " +
        "LOWER(a.technician.user.name) LIKE LOWER(CONCAT('%', :keyword, '%')) OR " +
        "LOWER(a.service.name) LIKE LOWER(CONCAT('%', :keyword, '%'))) " +
        "ORDER BY a.startTime DESC")
Page<Appointment> findAppointmentsForAdmin(
    @Param("keyword") String keyword,
    @Param("status") String status,
    Pageable pageable
);

// Controller
@GetMapping("/appointments")
public ResponseEntity<Page<AppointmentDto>> getAppointments(
        @RequestParam(required = false) String keyword,
        @RequestParam(required = false) String status,
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "20") int size) {
    
    Pageable pageable = PageRequest.of(page, size);
    Page<Appointment> appointments = appointmentRepository
            .findAppointmentsForAdmin(keyword, status, pageable);
    
    return ResponseEntity.ok(appointments.map(AppointmentDto::fromEntity));
}
```

### 3) SQL Execution Details

**SQL Type:** SELECT (complex WHERE with dynamic filters)  
**Target Tables:** appointment, customer, technician, services  

**SQL Generated:**
```sql
SELECT a.* FROM appointment a
JOIN customer c ON a.customer_id = c.customer_id
JOIN technician t ON a.technician_id = t.technician_id
JOIN services s ON a.service_id = s.service_id
WHERE (? IS NULL OR a.status = ?)
  AND (? IS NULL OR ? = '' OR
       LOWER(c.user.name) LIKE LOWER(CONCAT('%', ?, '%')) OR
       LOWER(t.user.name) LIKE LOWER(CONCAT('%', ?, '%')) OR
       LOWER(s.name) LIKE LOWER(CONCAT('%', ?, '%')))
ORDER BY a.start_time DESC
LIMIT 20 OFFSET 0
```

**Parameter Binding:**
- status: VARCHAR (nullable, can be null)
- keyword: VARCHAR (nullable, can be null or empty)
- keyword (repeated): Used in 3 LIKE clauses

**Execution Flow:**
1. Controller receives GET request with query params
2. Creates Pageable from page/size parameters
3. Calls repository.findAppointmentsForAdmin()
4. Spring Data JPA detects @Query
5. Translates JPQL to SQL:
   - Multiple JOINs for customer/technician/service lookups
   - Dynamic WHERE conditions (IS NULL checks)
   - CASE-INSENSITIVE search (LOWER() on both sides)
   - Wild cards in LIKE ('%' + keyword + '%')
6. Adds pagination: LIMIT 20 OFFSET 0
7. Executes query
8. PostgreSQL returns ResultSet
9. Hibernate maps to List<Appointment>
10. Wraps in Page<Appointment> with metadata
11. Returns Page with total count, page info, etc.

### 4) Java Object ↔ PostgreSQL Row Mapping

**Java Object:** Page<Appointment>  
**Mapping Type:** Entity collection with pagination metadata

**Column → Field Mapping:**
```
appointment.appointment_id         → Appointment.appointmentId
appointment.customer_id            → Appointment.customer (FK + JOIN)
appointment.technician_id          → Appointment.technician (FK + JOIN)
appointment.service_id             → Appointment.service (FK + JOIN)
appointment.start_time             → Appointment.startTime
appointment.status                 → Appointment.status
(all Appointment fields)           → (all Appointment entity fields)
```

**Pagination Metadata:**
```
Total elements in DB              → Page.totalElements
Current page number               → Page.number
Page size                          → Page.size
Total pages                        → Page.totalPages
Has next page                      → Page.hasNext()
Has previous page                  → Page.hasPrevious()
```

### 5) PostgreSQL Trigger Interaction

**Trigger Exists:** NONE (SELECT only)

### 6) Transaction & Exception Flow

**Transaction Start:** Not explicitly marked (default read-only)  
**Scope:** SELECT within transaction

**Success Path:**
1. Query executes with all parameters bound
2. ResultSet returned
3. Entities mapped
4. Page wrapper created
5. Controller receives Page<Appointment>
6. HTTP 200 OK

**Failure Paths:**

**Scenario A: Invalid search parameters**
```
Query executes
    ↓
No matching appointments found
    ↓
Empty Page<Appointment> returned (but valid)
    ↓
totalElements = 0
    ↓
HTTP 200 OK with empty list
```

**Scenario B: Database connection timeout**
```
Complex query with multiple JOINs takes too long
    ↓
JDBC timeout
    ↓
SQLException
    ↓
DataAccessException thrown
    ↓
HTTP 500 Internal Server Error
```

### 7) Final Outcome

**Success - Appointments found:**
```json
{
  "content": [
    {
      "appointmentId": 42,
      "customerName": "John Doe",
      "technicianName": "Sarah Smith",
      "serviceName": "Deep Tissue Massage",
      "startTime": "2025-01-20T14:00:00",
      "status": "CONFIRMED"
    }
  ],
  "totalElements": 150,
  "totalPages": 8,
  "currentPage": 0,
  "pageSize": 20,
  "hasNext": true
}
```
- Results paginated
- Sorted by startTime DESC
- HTTP 200 OK

**Success - No results:**
```json
{
  "content": [],
  "totalElements": 0,
  "totalPages": 0,
  "currentPage": 0,
  "pageSize": 20,
  "hasNext": false
}
```
- Empty page returned
- HTTP 200 OK

**Failure - Timeout:**
```json
{
  "error": "Query timeout retrieving appointments",
  "status": 500
}
```
- HTTP 500 Internal Server Error

---

## FUNCTION 14: UserRepository.searchCustomers()

**Function Name:** searchCustomers(String keyword, Pageable pageable)  
**Layer:** Repository  
**File Path:** Backend/auracontrol/src/main/java/com/example/auracontrol/user/repository/UserRepository.java  
**Class:** UserRepository  
**Triggered API:** GET /api/admin/customers  
**HTTP Method + URL:** GET /api/admin/customers?keyword=&page=0&size=20  
**CRUD Type:** READ (paginated text search)

### 1) Execution Path

```
HTTP GET /api/admin/customers?keyword=john&page=0&size=20
    ↓
AdminCustomerController.searchCustomers(keyword, pageable)
    ↓
AdminCustomerService.searchCustomers(keyword, pageable)
    ↓
userRepository.searchCustomers(keyword, pageable)  ← HERE
    ↓
Spring Data JPA executes @Query with pagination
    ↓
PostgreSQL executes:
    ├─ WHERE role = 'CUSTOMER' AND enabled = true
    ├─ WHERE name OR email LIKE keyword
    ├─ ORDER BY created_at DESC
    └─ LIMIT 20 OFFSET 0
    ↓
ResultSet mapped to Page<User>
    ↓
Service maps to CustomerDto
    ↓
Controller returns paginated JSON response
```

### 2) Critical Code Snippet

```java
// UserRepository.java (Line 44-49)
@Query("SELECT u FROM User u WHERE u.role = 'CUSTOMER' " +
        "AND u.enabled = true " +
        "AND (:keyword IS NULL OR :keyword = '' OR " +
        "LOWER(u.name) LIKE LOWER(CONCAT('%', :keyword, '%')) OR " +
        "LOWER(u.email) LIKE LOWER(CONCAT('%', :keyword, '%')))")
Page<User> searchCustomers(@Param("keyword") String keyword, Pageable pageable);

// Controller
@GetMapping("/search")
public ResponseEntity<Page<CustomerDto>> searchCustomers(
        @RequestParam(required = false) String keyword,
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "20") int size) {
    
    Pageable pageable = PageRequest.of(page, size, Sort.by("createdAt").descending());
    Page<User> users = userRepository.searchCustomers(keyword, pageable);
    
    return ResponseEntity.ok(users.map(user -> 
        CustomerDto.builder()
            .userId(user.getUserId())
            .name(user.getName())
            .email(user.getEmail())
            .build()
    ));
}
```

### 3) SQL Execution Details

**SQL Type:** SELECT (text search with pagination)  
**Target Table:** users  

**SQL Generated:**
```sql
SELECT u.* FROM users u
WHERE u.role = 'CUSTOMER'
  AND u.is_enabled = true
  AND (? IS NULL OR ? = '' OR
       LOWER(u.name) LIKE LOWER(CONCAT('%', ?, '%')) OR
       LOWER(u.email) LIKE LOWER(CONCAT('%', ?, '%')))
ORDER BY u.created_at DESC
LIMIT 20 OFFSET 0
```

**Parameter Binding:**
- keyword: VARCHAR (nullable, can be null or empty string)
- keyword (repeated): Used in 2 LIKE clauses for name and email

**Execution Flow:**
1. Controller receives request with keyword
2. Creates Pageable with sort criteria
3. Calls repository.searchCustomers(keyword, pageable)
4. Hibernate translates JPQL to SQL:
   - Filter role = 'CUSTOMER'
   - Filter is_enabled = true
   - Dynamic keyword matching with LIKE (case-insensitive)
   - Pagination (LIMIT/OFFSET)
5. PreparedStatement created
6. Executes query
7. PostgreSQL returns ResultSet
8. Hibernate maps to List<User>
9. Wraps in Page<User>
10. Controller maps User → CustomerDto

### 4) Java Object ↔ PostgreSQL Row Mapping

**Java Object:** Page<User>  
**Mapping Type:** Entity collection with pagination

**Column → Field Mapping:**
```
users.user_id          → User.userId
users.name             → User.name
users.email            → User.email
users.role             → User.role
users.is_enabled       → User.enabled
users.created_at       → User.createdAt
(all User fields)      → (all User entity fields)
```

### 5) PostgreSQL Trigger Interaction

**Trigger Exists:** NONE (SELECT only)

### 6) Transaction & Exception Flow

**Transaction Start:** Not explicitly marked (read-only)  
**Scope:** SELECT within transaction

**Success Path:**
1. Query executes
2. Filters applied (role, enabled, keyword)
3. Sorted by createdAt DESC
4. Paginated
5. ResultSet mapped
6. Page<User> returned
7. HTTP 200 OK

**Failure Paths:**

**Scenario A: No customers found**
```
Query executes
    ↓
WHERE clause matches 0 rows
    ↓
Empty Page<User> returned
    ↓
HTTP 200 OK with empty list
```

**Scenario B: Database error**
```
Connection failure or timeout
    ↓
SQLException
    ↓
DataAccessException
    ↓
HTTP 500 Internal Server Error
```

### 7) Final Outcome

**Success - Customers found:**
```json
{
  "content": [
    {
      "userId": 5,
      "name": "John Doe",
      "email": "john@example.com"
    },
    {
      "userId": 8,
      "name": "Jane Johnson",
      "email": "jane@example.com"
    }
  ],
  "totalElements": 45,
  "totalPages": 3,
  "currentPage": 0,
  "pageSize": 20
}
```
- Enabled customers matching keyword
- Paginated results
- HTTP 200 OK

**Success - No results:**
```json
{
  "content": [],
  "totalElements": 0,
  "totalPages": 0
}
```
- Empty list returned
- HTTP 200 OK

---

## FUNCTION 15: AppointmentRepository.getRevenueStatistics()

**Function Name:** getRevenueStatistics(LocalDateTime startDate, LocalDateTime endDate, String type)  
**Layer:** Repository  
**File Path:** Backend/auracontrol/src/main/java/com/example/auracontrol/booking/repository/AppointmentRepository.java  
**Class:** AppointmentRepository  
**Triggered API:** GET /api/admin/revenue/stats  
**HTTP Method + URL:** GET /api/admin/revenue/stats?startDate=&endDate=&type=DAILY  
**CRUD Type:** READ (calls PostgreSQL function)

### 1) Execution Path

```
HTTP GET /api/admin/revenue/stats?startDate=2025-01-01&endDate=2025-01-31&type=DAILY
    ↓
DashboardController.getRevenueStatistics(startDate, endDate, type)
    ↓
DashboardService.getRevenueStatistics(startDate, endDate, type)
    ↓
appointmentRepository.getRevenueStatistics(startDate, endDate, type)  ← HERE
    ↓
Spring Data JPA executes native SQL query
    ↓
PostgreSQL function called: get_revenue_statistics(startDate, endDate, type)
    ↓
Function:
    ├─ Queries appointment table (COMPLETED status)
    ├─ Groups by period (DAILY/MONTHLY/YEARLY)
    ├─ SUM(final_price) for each period
    ├─ COUNT(appointment_id) for each period
    └─ Returns aggregated statistics
    ↓
ResultSet mapped to List<RevenueStatDto>
    ↓
Service returns to Controller
```

### 2) Critical Code Snippet

```java
// AppointmentRepository.java (Line 37-42)
@Query(value = "SELECT * FROM get_revenue_statistics(:startDate, :endDate, :type)", 
       nativeQuery = true)
List<RevenueStatDto> getRevenueStatistics(
    @Param("startDate") LocalDateTime startDate,
    @Param("endDate") LocalDateTime endDate,
    @Param("type") String type
);

// DashboardController
@GetMapping("/revenue/stats")
public ResponseEntity<RevenueResponse> getRevenueStatistics(
        @RequestParam LocalDateTime startDate,
        @RequestParam LocalDateTime endDate,
        @RequestParam(defaultValue = "DAILY") String type) {
    
    List<RevenueStatDto> stats = appointmentRepository
            .getRevenueStatistics(startDate, endDate, type);
    
    return ResponseEntity.ok(new RevenueResponse(stats));
}
```

### 3) SQL Execution Details

**SQL Type:** SELECT (function call)  
**Function Called:** get_revenue_statistics(p_start_date, p_end_date, p_type)  
**Target Tables Queried Inside Function:**
- appointment
- service

**SQL Generated:**
```sql
SELECT * FROM get_revenue_statistics(:startDate, :endDate, :type)
```

**Parameter Binding:**
- startDate: TIMESTAMP
- endDate: TIMESTAMP
- type: VARCHAR ('DAILY', 'MONTHLY', 'YEARLY')

**Execution Flow Inside Function:**
```sql
-- Simplified function logic
IF p_type = 'DAILY' THEN
    SELECT 
        DATE(a.start_time) as period,
        COUNT(*) as appointment_count,
        COALESCE(SUM(a.final_price), 0) as total_revenue
    FROM appointment a
    WHERE a.status = 'COMPLETED'
      AND a.end_time BETWEEN p_start_date AND p_end_date
    GROUP BY DATE(a.start_time)
    ORDER BY period ASC;
    
ELSIF p_type = 'MONTHLY' THEN
    SELECT 
        DATE_TRUNC('month', a.start_time) as period,
        COUNT(*) as appointment_count,
        COALESCE(SUM(a.final_price), 0) as total_revenue
    FROM appointment a
    WHERE a.status = 'COMPLETED'
      AND a.end_time BETWEEN p_start_date AND p_end_date
    GROUP BY DATE_TRUNC('month', a.start_time)
    ORDER BY period ASC;
END IF;
```

**Execution Path:**
1. Controller calls repository.getRevenueStatistics()
2. @Query with nativeQuery=true detected
3. Spring binds parameters
4. Hibernate executes native SQL:
   ```
   SELECT * FROM get_revenue_statistics('2025-01-01'::TIMESTAMP, '2025-01-31'::TIMESTAMP, 'DAILY')
   ```
5. PostgreSQL receives function call
6. Function body executes (IF/THEN branching)
7. Queries appointment table
8. Aggregates by period
9. Returns SETOF records (table of statistics)
10. Hibernate maps ResultSet to List<RevenueStatDto>

### 4) Java Object ↔ PostgreSQL Row Mapping

**Java Object:** RevenueStatDto (DTO, not entity)  
**Mapping Type:** Manual ResultSet mapping from function result

**Column → Field Mapping:**
```
Function result columns:
    period               → RevenueStatDto.period (DATE/TIMESTAMP)
    appointment_count    → RevenueStatDto.appointmentCount (Long)
    total_revenue        → RevenueStatDto.totalRevenue (BigDecimal)
```

**DTO Structure:**
```java
public class RevenueStatDto {
    private LocalDate period;           // For DAILY
    // or LocalDateTime period;         // For MONTHLY/YEARLY
    private Long appointmentCount;
    private BigDecimal totalRevenue;
    // getters/setters
}
```

### 5) PostgreSQL Trigger Interaction

**Trigger Exists:** NONE triggered (SELECT only, inside function)

### 6) Transaction & Exception Flow

**Transaction Start:** @Transactional on DashboardService (if marked)  
**Scope:** SELECT within transaction (read-only)

**Success Path:**
1. Function executes
2. Aggregates data
3. Returns ResultSet
4. List<RevenueStatDto> populated
5. Service receives list
6. HTTP 200 OK

**Failure Paths:**

**Scenario A: Invalid date parameters**
```
startDate > endDate
    ↓
Function receives invalid parameters
    ↓
Function logic handles (returns empty result or error)
    ↓
Empty List<RevenueStatDto> returned
    ↓
HTTP 200 OK with empty list
```

**Scenario B: No completed appointments in range**
```
Query within function:
    WHERE a.status = 'COMPLETED' AND a.end_time BETWEEN ? AND ?
    ↓
No matching rows
    ↓
Empty ResultSet
    ↓
List<RevenueStatDto> = [] (empty)
    ↓
HTTP 200 OK with empty list
```

**Scenario C: Database query timeout (complex aggregation)**
```
Function processes millions of appointments
    ↓
Query takes > 30 seconds
    ↓
JDBC timeout
    ↓
SQLException
    ↓
DataAccessException
    ↓
HTTP 504 Gateway Timeout
```

**Scenario D: Function error**
```
PostgreSQL function has syntax error or runtime error
    ↓
Exception raised
    ↓
JDBC receives error
    ↓
DataAccessException
    ↓
HTTP 500 Internal Server Error
```

### 7) Final Outcome

**Success - DAILY breakdown:**
```json
[
  {
    "period": "2025-01-01",
    "appointmentCount": 12,
    "totalRevenue": 1200.00
  },
  {
    "period": "2025-01-02",
    "appointmentCount": 8,
    "totalRevenue": 800.00
  },
  {
    "period": "2025-01-03",
    "appointmentCount": 15,
    "totalRevenue": 1500.00
  }
]
```
- Daily revenue breakdown
- Grouped by date
- Sorted chronologically
- HTTP 200 OK

**Success - MONTHLY breakdown:**
```json
[
  {
    "period": "2025-01-01",
    "appointmentCount": 250,
    "totalRevenue": 25000.00
  },
  {
    "period": "2025-02-01",
    "appointmentCount": 280,
    "totalRevenue": 28000.00
  }
]
```
- Monthly aggregation
- Total revenue per month
- HTTP 200 OK

**Success - No appointments:**
```json
[]
```
- Empty list
- No completed appointments in date range
- HTTP 200 OK

**Failure - Timeout:**
```json
{
  "error": "Revenue statistics query timeout",
  "status": 504
}
```
- Complex aggregation timed out
- HTTP 504 Gateway Timeout

---

## Summary: Functions 11-15

| # | Function | Type | SQL | Triggers | TX Scope |
|---|----------|------|-----|----------|----------|
| 11 | findBusyResourceIds() | READ | SELECT (JOIN) | None | Inside TX |
| 12 | findAvailableResources() | READ | SELECT (IN clause) | None | Inside TX |
| 13 | findAppointmentsForAdmin() | READ | SELECT (paginated) | None | Inside TX |
| 14 | searchCustomers() | READ | SELECT (text search) | None | Inside TX |
| 15 | getRevenueStatistics() | READ | SELECT (function) | None | Inside TX |

### Key Patterns

**Complex JOINs (11, 13):**
- ✅ Multiple table joins for relationships
- ✅ Time overlap logic (start < end AND end > start)
- ✅ Status filtering (!= 'CANCELLED')
- ✅ Dynamic parameter binding

**Dynamic IN Clauses (12):**
- ✅ Collection<Integer> binds as (?, ?, ?)
- ✅ Placeholder (-1) for empty collections
- ✅ Performance consideration for large lists

**Pagination (13, 14):**
- ✅ Page<T> wraps results with metadata
- ✅ LIMIT/OFFSET generated automatically
- ✅ Total count query for pagination info
- ✅ Sort order applied (DESC/ASC)

**Text Search (13, 14):**
- ✅ LOWER() for case-insensitive matching
- ✅ LIKE with wildcard '%' + keyword + '%'
- ✅ Multiple fields searchable (name, email, etc.)
- ✅ NULL/empty checks for optional keywords

**Aggregation Functions (15):**
- ✅ PostgreSQL function encapsulates complex logic
- ✅ GROUP BY with date functions
- ✅ SUM/COUNT aggregations
- ✅ IF/THEN branching by type parameter

---

**Document:** jpa_11_15.md  
**Token Count:** ~8,800  
**Total with jpa_1_5 + jpa_6_10:** ~26,500  
**Remaining Budget:** ~173,500 tokens ✅

All 15 critical functions documented with complete execution traces.
