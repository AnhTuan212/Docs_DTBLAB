# Backend Communication Architecture: Repository Layer

**Project:** AuraControl Spa Management System  
**Layer:** Repository Layer (Data Access & Query Abstraction)  
**Date:** December 30, 2025

---

## TABLE OF CONTENTS
1. [Repository Layer Overview](#repository-layer-overview)
2. [JPA Repository Architecture](#jpa-repository-architecture)
3. [Query Types & Generation](#query-types--generation)
4. [EntityManager & Persistence Context](#entitymanager--persistence-context)
5. [Java Entity to PostgreSQL Mapping](#java-entity-to-postgresql-mapping)
6. [SQL Generation & Execution](#sql-generation--execution)
7. [Repository Layer Communication Flow](#repository-layer-communication-flow)
8. [AuraControl Repository Examples](#auracontrol-repository-examples)
9. [Query Execution Deep Dive](#query-execution-deep-dive)
10. [Performance Considerations](#performance-considerations)

---

## REPOSITORY LAYER OVERVIEW

### What is the Repository Layer?

The **Repository Layer** is the **data access abstraction tier**. It sits between the **Service Layer** (above) and the **Database** (below).

**Responsibilities:**
1. **Provide database query methods** (find, save, delete, update)
2. **Abstract SQL complexity** (Java developers write minimal SQL)
3. **Execute JPA queries** (Spring Data JPA auto-generates implementations)
4. **Map database rows to Java objects** (automatic ResultSet → Entity conversion)
5. **Manage entity lifecycle** (attached, detached, transient states)
6. **Handle database transactions** (coordinate with @Transactional)

### Why Separate Repository Layer?

```
❌ WITHOUT Repository Layer:
Service → Raw JDBC/SQL → Database
❌ SQL scattered across codebase
❌ Manual ResultSet mapping
❌ No compile-time type safety
❌ Hard to test (real DB required)

✅ WITH Repository Layer:
Service → Repository (interface) → Impl (generated) → JPA → SQL → Database
✅ SQL centralized in one place
✅ Automatic ResultSet mapping
✅ Type-safe queries
✅ Easy to test (mock repository)
✅ Switch databases without code change
```

### Repository Pattern

```
┌─────────────────────────────────┐
│ Service Layer                   │
│ (Calls repositories)            │
└────────────┬────────────────────┘
             │
             ↓
┌─────────────────────────────────┐
│ Repository Interface (Abstract) │
│ ├─ UserRepository               │
│ ├─ TechnicianRepository         │
│ ├─ AppointmentRepository        │
│ ├─ ServiceRepository            │
│ └─ ... others                   │
└────────────┬────────────────────┘
             │
             ↓
┌─────────────────────────────────┐
│ Spring Data JPA Implementation  │
│ (Auto-generated by Spring)      │
│ ├─ QueryLookupStrategy          │
│ ├─ QueryExecutor                │
│ └─ ResultMapping                │
└────────────┬────────────────────┘
             │
             ↓
┌─────────────────────────────────┐
│ Hibernate ORM Framework         │
│ ├─ Criteria API                 │
│ ├─ HQL → SQL Translation        │
│ └─ Entity Mapping               │
└────────────┬────────────────────┘
             │
             ↓
┌─────────────────────────────────┐
│ Database Connection Pool        │
│ (HikariCP / Connection Manager) │
└────────────┬────────────────────┘
             │
             ↓
┌─────────────────────────────────┐
│ PostgreSQL Database             │
└─────────────────────────────────┘
```

### AuraControl Repository Layer Structure

```
┌──────────────────────────────────────────────────────────────┐
│ REPOSITORY INTERFACES (85 query methods total)               │
│                                                               │
│ User Management:                                              │
│ ├─ UserRepository (11 methods)                               │
│ ├─ TechnicianRepository (6 methods)                          │
│ └─ CustomerRepository (3 methods)                            │
│                                                               │
│ Booking Management:                                           │
│ ├─ AppointmentRepository (13 methods)                        │
│ ├─ AbsenceRequestRepository (6 methods)                      │
│ ├─ ResourceRepository (10 methods)                           │
│ └─ AppointmentResourceRepository (1 method)                  │
│                                                               │
│ Service Management:                                           │
│ ├─ ServiceRepository (8 methods)                             │
│ └─ ServiceResourceRequirementRepository (2 methods)          │
└──────────────────────────────────────────────────────────────┘
```

---

## JPA REPOSITORY ARCHITECTURE

### Spring Data JPA Foundation

```java
// What developers write (Interface):
public interface UserRepository extends JpaRepository<User, Long> {
    // Method declarations only
    Optional<User> findByEmail(String email);
    List<User> findAllByRoleAndEnabledTrue(Role role);
}

// What Spring generates at runtime (Implementation):
public class UserRepositoryImpl implements UserRepository {
    private EntityManager entityManager;
    
    public Optional<User> findByEmail(String email) {
        // Generated by Spring based on method name
        Query query = entityManager.createQuery(
            "SELECT u FROM User u WHERE u.email = :email"
        );
        query.setParameter("email", email);
        try {
            return Optional.of((User) query.getSingleResult());
        } catch (NoResultException e) {
            return Optional.empty();
        }
    }
    
    public List<User> findAllByRoleAndEnabledTrue(Role role) {
        // Generated by Spring based on method name
        Query query = entityManager.createQuery(
            "SELECT u FROM User u WHERE u.role = :role AND u.enabled = true"
        );
        query.setParameter("role", role);
        return query.getResultList();
    }
}
```

### JpaRepository Base Methods

```java
public interface JpaRepository<T, ID> extends PagingAndSortingRepository<T, ID> {
    // CRUD Methods automatically available:
    
    // Create/Update
    T save(T entity);                          // INSERT or UPDATE
    Iterable<T> saveAll(Iterable<T> entities); // Batch INSERT/UPDATE
    
    // Read
    Optional<T> findById(ID id);               // SELECT by primary key
    List<T> findAll();                         // SELECT all rows
    List<T> findAllById(Iterable<ID> ids);     // SELECT multiple rows
    boolean existsById(ID id);                 // Check if exists
    
    // Count
    long count();                              // COUNT(*)
    
    // Delete
    void deleteById(ID id);                    // DELETE by primary key
    void delete(T entity);                     // DELETE by entity
    void deleteAll(Iterable<T> entities);      // Batch DELETE
    void deleteAll();                          // DELETE all rows
    
    // Paging & Sorting (from PagingAndSortingRepository)
    Page<T> findAll(Pageable pageable);        // Paginated results
    List<T> findAll(Sort sort);                // Sorted results
}
```

### Repository Interface Example

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    // ============ DERIVED QUERY METHODS ============
    // Spring Data JPA auto-generates SQL from method name
    
    Optional<User> findByEmail(String email);
    // Generated SQL: SELECT u FROM User u WHERE u.email = :email
    
    boolean existsByEmail(String email);
    // Generated SQL: SELECT CASE WHEN COUNT(u) > 0 THEN true ELSE false END FROM User u WHERE u.email = :email
    
    List<User> findByRole(Role role);
    // Generated SQL: SELECT u FROM User u WHERE u.role = :role
    
    // ============ @Query ANNOTATION METHODS ============
    // Developer writes explicit JPQL query
    
    @Query("SELECT u FROM User u WHERE u.email = :email")
    Optional<User> findByEmailCustom(@Param("email") String email);
    
    @Query("SELECT u FROM User u WHERE u.role = :role AND u.enabled = true")
    List<User> findActiveUsersByRole(@Param("role") Role role);
    
    // ============ @Query NATIVE SQL METHODS ============
    // Developer writes native PostgreSQL SQL
    
    @Query(value = "SELECT * FROM users WHERE email = :email", nativeQuery = true)
    Optional<User> findByEmailNative(@Param("email") String email);
    
    // ============ @Modifying METHODS ============
    // For UPDATE and DELETE operations
    
    @Modifying
    @Query("UPDATE User u SET u.password = :password WHERE u.userId = :id")
    void updatePassword(@Param("id") Long id, @Param("password") String password);
    
    @Modifying
    @Transactional
    @Query("DELETE FROM User u WHERE u.email = :email")
    int deleteByEmail(@Param("email") String email);
}
```

### How Spring Creates Implementations

```
1. APPLICATION STARTUP
   ├─ Spring scans classpath
   ├─ Finds all interfaces extending JpaRepository
   └─ For each interface:
      ├─ Parse method signatures
      ├─ Look for @Query annotations
      ├─ If no @Query: auto-generate JPQL from method name
      └─ Create proxy implementation

2. AT RUNTIME
   ├─ When service calls repository.findByEmail("user@example.com")
   ├─ Proxy intercepts call
   ├─ Extracts method name: "findByEmail"
   ├─ Converts to JPQL: "SELECT u FROM User u WHERE u.email = :email"
   ├─ Sets parameter: email = "user@example.com"
   ├─ Executes query against database
   └─ Returns result wrapped in Optional

3. RESULT MAPPING
   ├─ Database returns ResultSet
   ├─ Spring maps each row to User entity
   ├─ User object populated with column values
   └─ Returned to service
```

---

## QUERY TYPES & GENERATION

### Type 1: Derived Query Methods (Method Name → SQL)

```java
// Method naming convention:
// find + [All|First] + By + Property + [Comparison] + [And|Or] + Property...

public interface AppointmentRepository extends JpaRepository<Appointment, Integer> {
    
    // Simple equals
    List<Appointment> findByStatus(String status);
    // SQL: SELECT a FROM Appointment a WHERE a.status = :status
    
    // Multiple conditions (AND)
    List<Appointment> findByStatusAndTechnicianId(String status, Integer techId);
    // SQL: SELECT a FROM Appointment a WHERE a.status = :status AND a.technicianId = :techId
    
    // Nested property access
    Optional<Appointment> findByCustomer_User_Email(String email);
    // SQL: SELECT a FROM Appointment a WHERE a.customer.user.email = :email
    
    // Comparison operators
    List<Appointment> findByStartTimeAfter(LocalDateTime startTime);
    // SQL: SELECT a FROM Appointment a WHERE a.startTime > :startTime
    
    List<Appointment> findByStartTimeBeforeAndStatusNot(LocalDateTime before, String status);
    // SQL: SELECT a FROM Appointment a WHERE a.startTime < :before AND a.status != :status
    
    // Ordering
    List<Appointment> findByStatusOrderByStartTimeDesc(String status);
    // SQL: SELECT a FROM Appointment a WHERE a.status = :status ORDER BY a.startTime DESC
    
    // First result only
    Optional<Appointment> findFirstByStatusAndTechnicianIdOrderByStartTimeAsc(
        String status, 
        Integer techId
    );
    // SQL: SELECT a FROM Appointment a WHERE a.status = :status AND a.technicianId = :techId ORDER BY a.startTime ASC LIMIT 1
    
    // Exists check
    boolean existsByCustomerId(Integer customerId);
    // SQL: SELECT CASE WHEN COUNT(a) > 0 THEN true ELSE false END FROM Appointment a WHERE a.customerId = :customerId
    
    // Count
    long countByStatusAndStartTimeBetween(String status, LocalDateTime start, LocalDateTime end);
    // SQL: SELECT COUNT(a) FROM Appointment a WHERE a.status = :status AND a.startTime BETWEEN :start AND :end
}
```

### Type 2: @Query with JPQL (Java Persistence Query Language)

```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    // Basic @Query
    @Query("SELECT u FROM User u WHERE u.email = :email")
    Optional<User> findByEmail(@Param("email") String email);
    
    // Complex conditions
    @Query("SELECT u FROM User u WHERE u.role = :role AND u.enabled = true")
    List<User> findActiveByRole(@Param("role") Role role);
    
    // JOIN queries
    @Query("SELECT u FROM User u " +
           "JOIN u.technician t " +
           "WHERE t.isActive = true")
    List<User> findActiveUsers();
    
    // COUNT aggregation
    @Query("SELECT COUNT(u) FROM User u WHERE u.role = 'CUSTOMER' AND u.createdAt > :date")
    long countNewCustomers(@Param("date") LocalDateTime date);
    
    // GROUP BY
    @Query("SELECT new map(u.role as role, COUNT(u) as count) " +
           "FROM User u GROUP BY u.role")
    List<Map<String, Object>> countByRole();
    
    // Subqueries
    @Query("SELECT u FROM User u WHERE u.userId NOT IN " +
           "(SELECT DISTINCT a.customer.userId FROM Appointment a)")
    List<User> findUsersWithoutAppointments();
    
    // CASE expressions
    @Query("SELECT new com.example.dto.UserDto(" +
           "u.userId, " +
           "u.name, " +
           "CASE WHEN u.enabled = true THEN 'Active' ELSE 'Inactive' END) " +
           "FROM User u")
    List<UserDto> findAllWithStatus();
    
    // UPDATE operation
    @Modifying
    @Query("UPDATE User u SET u.password = :password WHERE u.userId = :id")
    void updatePassword(@Param("id") Long id, @Param("password") String password);
    
    // DELETE operation
    @Modifying
    @Query("DELETE FROM User u WHERE u.email = :email")
    int deleteByEmail(@Param("email") String email);
}
```

### Type 3: @Query with Native SQL

```java
public interface TechnicianRepository extends JpaRepository<Technician, Integer> {
    
    // Calling PostgreSQL function
    @Query(value = "SELECT * FROM get_available_technicians(:serviceId, CAST(:checkTime AS TIMESTAMP))",
           nativeQuery = true)
    List<TechnicianOptionDto> findAvailableTechnicians(
        @Param("serviceId") Integer serviceId,
        @Param("checkTime") LocalDateTime checkTime
    );
    
    // Complex JOIN with native SQL
    @Query(value = "SELECT t.* FROM technician t " +
                   "JOIN technician_services ts ON t.technician_id = ts.technician_id " +
                   "WHERE ts.service_id = :serviceId AND t.is_active = true",
           nativeQuery = true)
    List<Technician> findAllByServiceId(@Param("serviceId") Integer serviceId);
    
    // Using PostgreSQL specific functions
    @Query(value = "SELECT * FROM technician " +
                   "WHERE similarity(name, :name) > 0.8",
           nativeQuery = true)
    List<Technician> findBySimilarName(@Param("name") String name);
}

public interface AppointmentRepository extends JpaRepository<Appointment, Integer> {
    
    // Querying a database VIEW
    @Query(value = "SELECT * FROM v_upcoming_appointments LIMIT 10",
           nativeQuery = true)
    List<UpcomingAppointmentDto> getUpcomingAppointmentsView();
    
    // Calling PostgreSQL function that returns data
    @Query(value = "SELECT * FROM get_revenue_statistics(:startDate, :endDate, :period)",
           nativeQuery = true)
    List<RevenueStatDto> getRevenueStatistics(
        @Param("startDate") LocalDate startDate,
        @Param("endDate") LocalDate endDate,
        @Param("period") String period
    );
}
```

### Query Generation Workflow

```
┌─────────────────────────────────────────┐
│ Method declared in Repository interface │
│ findByStatusAndStartTimeBetween(...)    │
└────────────┬────────────────────────────┘
             │
             ├─ @Query exists?
             │  ├─ YES → Use explicit query
             │  └─ NO → Continue
             │
             ├─ Parse method name
             │  ├─ Extract: "find" + "ByStatusAndStartTimeBetween"
             │  ├─ Parse property: "Status" + "StartTime"
             │  └─ Parse operators: "Between"
             │
             ├─ Build JPQL
             │  ├─ SELECT a FROM Appointment a
             │  ├─ WHERE a.status = :status
             │  └─ AND a.startTime BETWEEN :startTime1 AND :startTime2
             │
             ├─ Register query
             │  └─ Cache for future use
             │
             └─ At runtime:
                ├─ Convert JPQL to native SQL
                ├─ Set parameter values
                ├─ Execute against PostgreSQL
                └─ Map results to entities
```

---

## ENTITYMANAGER & PERSISTENCE CONTEXT

### What is EntityManager?

**EntityManager** is the **central component** that manages entity lifecycle and persistence.

```java
// EntityManager is injected by Spring
@Service
public class AppointmentService {
    @PersistenceContext
    private EntityManager entityManager;
    
    // EntityManager is used internally by repositories
    // Service layer doesn't directly use it (repositories use it)
}
```

### Entity Lifecycle States

```
┌──────────────────────────────────────────────────────────┐
│                ENTITY LIFECYCLE                          │
└──────────────────────────────────────────────────────────┘

1. TRANSIENT (New object, not yet saved)
   ├─ Appointment appt = new Appointment();
   ├─ No ID assigned
   ├─ Not tracked by EntityManager
   └─ Database doesn't know about it

2. PERSISTENT (Managed by EntityManager)
   ├─ Entity retrieved from database
   ├─ Entity passed to repository.save()
   ├─ Tracked by Persistence Context
   ├─ Changes automatically detected
   └─ Flushed to database at commit

3. DETACHED (Was managed, now detached)
   ├─ Transaction ended
   ├─ Session closed
   ├─ Entity still has ID
   ├─ Changes NOT tracked
   └─ Must merge() to persist changes

4. REMOVED (Marked for deletion)
   ├─ repository.delete() called
   ├─ Still in session temporarily
   ├─ Deleted at commit
   └─ Then becomes no longer managed

Transition Diagram:

NEW → repository.save() → PERSISTENT ← repository.findById()
                             ↓
                          @Transactional ends
                             ↓
                         DETACHED
                             ↓
                        entityManager.merge()
                             ↓
                         PERSISTENT again

repository.delete() → PERSISTENT → REMOVED → (committed) → No longer tracked
```

### Persistence Context (1st Level Cache)

```
┌──────────────────────────────────────────────────────────┐
│ EntityManager + Persistence Context                      │
│ (Per transaction)                                         │
│                                                          │
│ Transaction Starts                                        │
│ ┌──────────────────────────────────┐                    │
│ │ Persistence Context (Cache)      │                    │
│ │                                  │                    │
│ │ ID=1 → User(id=1, name="John")   │                    │
│ │ ID=2 → User(id=2, name="Jane")   │                    │
│ │ ID=3 → Appointment(...)          │                    │
│ │                                  │                    │
│ │ Benefits:                        │                    │
│ │ • Second query returns cached    │                    │
│ │ • Dirty checking (detects        │                    │
│ │   property changes)              │                    │
│ │ • Prevents duplicate objects     │                    │
│ └──────────────────────────────────┘                    │
│                                                          │
│ Example:                                                 │
│ User user1 = userRepository.findById(1);                │
│ // Query executed, added to cache                        │
│                                                          │
│ User user2 = userRepository.findById(1);                │
│ // No query! Returns from cache                          │
│ // user1 == user2 (same object reference)               │
│                                                          │
│ Transaction Commits/Flushes                              │
│ ├─ Dirty objects detected                               │
│ ├─ Change statements generated                          │
│ ├─ SQL executed                                         │
│ └─ Cache cleared (transaction ends)                     │
└──────────────────────────────────────────────────────────┘
```

### Dirty Checking Example

```java
@Service
public class UserService {
    private final UserRepository userRepository;
    
    @Transactional
    public void updateUserProfile(Long userId, String newName) {
        // Step 1: Retrieve user (becomes PERSISTENT)
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("User not found"));
        
        // User added to Persistence Context
        // Persistence Context tracks original state:
        // {name: "John", email: "john@example.com", ...}
        
        // Step 2: Modify object
        user.setName(newName);
        
        // User object modified, but NOT saved yet
        // Persistence Context knows: name changed from "John" to "Jane"
        
        // Step 3: NO repository.save() needed!
        // Just modifying object is enough
        
        // Step 4: End of @Transactional method
        // ├─ EntityManager flushes
        // ├─ Dirty checking detects: name changed
        // ├─ Generates: UPDATE users SET name = 'Jane' WHERE user_id = 1
        // ├─ Executes SQL
        // ├─ Commits transaction
        // └─ Persistence Context cleared
    }
}
```

### Important: Lazy Loading & Cascades

```java
@Entity
@Table(name = "appointment")
public class Appointment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer appointmentId;
    
    // EAGER loading: Related entity loaded immediately
    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "customer_id")
    private Customer customer;
    
    // LAZY loading: Related entity loaded only when accessed
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "technician_id")
    private Technician technician;
    
    // LAZY by default for collections
    @OneToMany(mappedBy = "appointment")
    private List<AppointmentResource> resources;
}

// Usage:
Appointment appt = appointmentRepository.findById(1).get();

// EAGER: Customer already loaded in same query
String customerName = appt.getCustomer().getName();  // No extra query

// LAZY: Technician not loaded yet
String techName = appt.getTechnician().getName();
// ↑ This triggers a NEW query if outside @Transactional!
// ↑ If outside @Transactional, throws LazyInitializationException

// Solution: Keep transaction open until all lazy properties accessed
@Transactional
public AppointmentDetailsDto getDetails(Integer appointmentId) {
    Appointment appt = appointmentRepository.findById(appointmentId).get();
    
    // All lazy properties accessible within transaction
    String techName = appt.getTechnician().getName();
    List<String> resources = appt.getResources()
        .stream()
        .map(r → r.getResource().getName())
        .collect(Collectors.toList());
    
    // Build DTO before transaction ends
    return AppointmentDetailsDto.builder()
        .customerName(appt.getCustomer().getName())
        .technicianName(techName)
        .resources(resources)
        .build();
}
```

---

## JAVA ENTITY TO POSTGRESQL MAPPING

### Entity Definition

```java
@Entity
@Table(name = "appointment")
public class Appointment {
    
    // Primary Key
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "appointment_id")
    private Integer appointmentId;
    
    // Simple columns
    @Column(name = "start_time", nullable = false)
    private LocalDateTime startTime;
    
    @Column(name = "end_time", nullable = false)
    private LocalDateTime endTime;
    
    @Column(name = "status", length = 50)
    private String status;
    
    @Column(name = "final_price", precision = 10, scale = 2)
    private BigDecimal finalPrice;
    
    // Foreign Keys (One-to-Many from perspective of Appointment)
    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "customer_id", nullable = false)
    private Customer customer;
    
    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "technician_id")
    private Technician technician;
    
    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "service_id", nullable = false)
    private Service service;
    
    // Collection of related entities
    @OneToMany(mappedBy = "appointment", cascade = CascadeType.ALL)
    private List<AppointmentResource> resources = new ArrayList<>();
    
    // Audit fields
    @Column(name = "created_at", nullable = false, updatable = false)
    @CreationTimestamp
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    @UpdateTimestamp
    private LocalDateTime updatedAt;
    
    // Constructors, getters, setters...
}
```

### Entity ↔ Database Mapping

```
JAVA Entity                           PostgreSQL Table

@Entity                               CREATE TABLE appointment (
@Table(name = "appointment")          
                                      
@Id                                   appointment_id SERIAL PRIMARY KEY,
appointmentId                         
                                      
@Column(name = "start_time")          start_time TIMESTAMP NOT NULL,
startTime                             
                                      
@Column(name = "end_time")            end_time TIMESTAMP NOT NULL,
endTime                               
                                      
@Column(name = "status", length=50)   status VARCHAR(50),
status                                
                                      
@Column(name = "final_price",         final_price DECIMAL(10, 2),
        precision=10, scale=2)        
finalPrice                            
                                      
@JoinColumn(name = "customer_id")     customer_id INTEGER NOT NULL REFERENCES customer(customer_id),
customer                              
                                      
@JoinColumn(name = "technician_id")   technician_id INTEGER REFERENCES technician(technician_id),
technician                            
                                      
@JoinColumn(name = "service_id")      service_id INTEGER NOT NULL REFERENCES services(service_id),
service                               
                                      
@CreationTimestamp                    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
@Column(name = "created_at")          
createdAt                             
                                      
@UpdateTimestamp                      updated_at TIMESTAMP DEFAULT NOW(),
@Column(name = "updated_at")          
updatedAt                             
                                      
                                      );
```

### JPA Annotations Explained

```
┌─────────────────────────┬──────────────────────────────────────────┐
│ Annotation              │ Purpose                                  │
├─────────────────────────┼──────────────────────────────────────────┤
│ @Entity                 │ Marks class as JPA entity (maps to table)│
│ @Table(name="...")      │ Specifies table name in database         │
│                         │                                          │
│ @Id                     │ Marks field as primary key               │
│ @GeneratedValue         │ Auto-generates ID (IDENTITY, SEQUENCE)   │
│ @Column(...)            │ Maps field to specific column            │
│                         │                                          │
│ @ManyToOne              │ Foreign key relationship (N:1)           │
│ @OneToMany              │ One-to-many relationship (1:N)           │
│ @ManyToMany             │ Many-to-many relationship (N:N)          │
│ @JoinColumn(name="...")│ Specifies foreign key column name        │
│ @OneToOne               │ One-to-one relationship (1:1)            │
│                         │                                          │
│ @CreationTimestamp      │ Auto-set on creation (Hibernate)         │
│ @UpdateTimestamp        │ Auto-update on modification (Hibernate)  │
│                         │                                          │
│ @Transient              │ Exclude field from mapping               │
│ @Lob                    │ Large object (CLOB/BLOB)                │
│ @Enumerated             │ Map Java enum to database                │
│ @Temporal               │ Map temporal types (Date/Time)           │
│                         │                                          │
│ @Version                │ Optimistic locking version               │
│ @LazyCollection(...)    │ Control lazy loading strategy            │
│ @Cascade(...)           │ Cascade operations (DELETE, etc)         │
└─────────────────────────┴──────────────────────────────────────────┘
```

---

## SQL GENERATION & EXECUTION

### Query Translation Pipeline

```
┌─────────────────────────────────────────────────────────────────┐
│ 1. SERVICE CALLS REPOSITORY METHOD                              │
│                                                                 │
│ List<Appointment> appts = appointmentRepository               │
│     .findByStartTimeBetweenAndStatusNot(                      │
│         startTime,                                            │
│         endTime,                                              │
│         "CANCELLED"                                           │
│     );                                                         │
└────────────┬────────────────────────────────────────────────────┘
             │
             ↓
┌─────────────────────────────────────────────────────────────────┐
│ 2. SPRING DATA JPA INTERCEPTS CALL                              │
│                                                                 │
│ ├─ Method name analyzed                                        │
│ ├─ Parameters extracted                                        │
│ ├─ No @Query found: Generate from method name                  │
│ └─ Generated JPQL built                                        │
└────────────┬────────────────────────────────────────────────────┘
             │
             ↓
┌─────────────────────────────────────────────────────────────────┐
│ 3. JPQL QUERY CREATED                                           │
│                                                                 │
│ Query query = entityManager.createQuery(                        │
│     "SELECT a FROM Appointment a " +                           │
│     "WHERE a.startTime BETWEEN :start AND :end " +             │
│     "AND a.status != :status"                                  │
│ );                                                              │
│                                                                 │
│ query.setParameter("start", startTime);                        │
│ query.setParameter("end", endTime);                            │
│ query.setParameter("status", "CANCELLED");                     │
└────────────┬────────────────────────────────────────────────────┘
             │
             ↓
┌─────────────────────────────────────────────────────────────────┐
│ 4. HIBERNATE TRANSLATES TO NATIVE SQL                           │
│                                                                 │
│ Hibernate dialect for PostgreSQL converts:                      │
│                                                                 │
│ SELECT a FROM Appointment a                                    │
│ ↓                                                               │
│ SELECT a.appointment_id,                                       │
│        a.start_time,                                           │
│        a.end_time,                                             │
│        a.status,                                               │
│        a.final_price,                                          │
│        a.customer_id,                                          │
│        a.technician_id,                                        │
│        a.service_id,                                           │
│        a.created_at,                                           │
│        a.updated_at                                            │
│ FROM appointment a                                             │
│ WHERE a.start_time BETWEEN $1 AND $2                           │
│ AND a.status != $3                                             │
└────────────┬────────────────────────────────────────────────────┘
             │
             ↓
┌─────────────────────────────────────────────────────────────────┐
│ 5. DATABASE CONNECTION OBTAINED                                 │
│                                                                 │
│ HikariCP Connection Pool                                        │
│ ├─ Check for available connection                              │
│ ├─ If available: reuse                                         │
│ ├─ If none available: create new                               │
│ └─ Set connection parameters                                   │
└────────────┬────────────────────────────────────────────────────┘
             │
             ↓
┌─────────────────────────────────────────────────────────────────┐
│ 6. EXECUTE AGAINST POSTGRESQL                                   │
│                                                                 │
│ JDBC PreparedStatement execution:                               │
│                                                                 │
│ PreparedStatement stmt = connection.prepareStatement(          │
│     "SELECT ... FROM appointment a WHERE ..."                  │
│ );                                                              │
│ stmt.setTimestamp(1, startTime);    // Parameter $1            │
│ stmt.setTimestamp(2, endTime);      // Parameter $2            │
│ stmt.setString(3, "CANCELLED");     // Parameter $3            │
│ ResultSet rs = stmt.executeQuery();                            │
│                                                                 │
│ PostgreSQL receives query, parses, optimizes plan, executes    │
└────────────┬────────────────────────────────────────────────────┘
             │
             ↓
┌─────────────────────────────────────────────────────────────────┐
│ 7. RESULTS RETURNED FROM DATABASE                               │
│                                                                 │
│ ResultSet                                                       │
│ ├─ Row 1: {1, 2025-01-15 09:00, 2025-01-15 10:00, ...}         │
│ ├─ Row 2: {2, 2025-01-15 10:30, 2025-01-15 11:30, ...}         │
│ └─ Row 3: {3, 2025-01-15 14:00, 2025-01-15 15:00, ...}         │
└────────────┬────────────────────────────────────────────────────┘
             │
             ↓
┌─────────────────────────────────────────────────────────────────┐
│ 8. HIBERNATE MAPS TO JAVA ENTITIES                              │
│                                                                 │
│ For each row in ResultSet:                                      │
│ ├─ Create new Appointment object                               │
│ ├─ Populate fields from columns                                │
│ ├─ Add to Persistence Context                                  │
│ └─ Load relationships (customer, technician, service)          │
│                                                                 │
│ Appointment appt1 = new Appointment();                          │
│ appt1.setAppointmentId(1);                                     │
│ appt1.setStartTime(LocalDateTime.parse("2025-01-15T09:00"));  │
│ appt1.setEndTime(LocalDateTime.parse("2025-01-15T10:00"));    │
│ appt1.setStatus("CONFIRMED");                                  │
│ appt1.setFinalPrice(new BigDecimal("45.00"));                  │
│ ... (more fields)                                              │
│ appt1.setCustomer(customerRepository.findById(customerId)...); │
│ appt1.setTechnician(technicianRepository.findById(techId)...); │
│ ... (repeat for rows 2, 3)                                     │
└────────────┬────────────────────────────────────────────────────┘
             │
             ↓
┌─────────────────────────────────────────────────────────────────┐
│ 9. LIST RETURNED TO SERVICE                                     │
│                                                                 │
│ List<Appointment> appts = [                                    │
│     Appointment(id=1, startTime=2025-01-15 09:00, ...),        │
│     Appointment(id=2, startTime=2025-01-15 10:30, ...),        │
│     Appointment(id=3, startTime=2025-01-15 14:00, ...)         │
│ ];                                                              │
│                                                                 │
│ Return to service layer                                        │
└─────────────────────────────────────────────────────────────────┘
```

### Example: Native SQL Query Execution

```java
// Repository method
@Query(value = "SELECT * FROM get_available_technicians(:serviceId, CAST(:checkTime AS TIMESTAMP))",
       nativeQuery = true)
List<TechnicianOptionDto> findAvailableTechnicians(
    @Param("serviceId") Integer serviceId,
    @Param("checkTime") LocalDateTime checkTime
);

// Execution flow:
// 1. Service calls: technicianRepository.findAvailableTechnicians(1, now)
// 2. Spring detects nativeQuery = true
// 3. Raw SQL executed directly (not JPQL translation)
// 4. PostgreSQL executes function: SELECT * FROM get_available_technicians(1, '2025-01-15 14:30:00')
// 5. Function returns matching technicians
// 6. Spring maps results to TechnicianOptionDto objects
// 7. List<TechnicianOptionDto> returned to service
```

---

## REPOSITORY LAYER COMMUNICATION FLOW

### Complete Data Access Sequence

```
┌──────────────────────────────┐
│ SERVICE CALLS REPOSITORY     │
│ .save(entity)                │
│ .findById(id)                │
│ .findAll()                   │
│ .delete(entity)              │
└────────────┬─────────────────┘
             │
             ↓
┌──────────────────────────────────────────────────────────┐
│ SPRING DATA JPA PROXY INTERCEPTS                         │
│                                                          │
│ 1. Identify method call                                  │
│ 2. Check Persistence Context (1st level cache)          │
│ 3. If cached & suitable: return from cache              │
│ 4. Otherwise: proceed to query execution                │
└────────────┬─────────────────────────────────────────────┘
             │
             ↓
┌──────────────────────────────────────────────────────────┐
│ QUERY GENERATION (if needed)                             │
│                                                          │
│ ├─ @Query annotation present?                           │
│ │  ├─ YES: Use explicit query                           │
│ │  └─ NO: Parse method name                             │
│ │                                                        │
│ ├─ Build JPQL (or use native SQL)                       │
│ ├─ Register parameters                                  │
│ └─ Create Query object                                  │
└────────────┬─────────────────────────────────────────────┘
             │
             ↓
┌──────────────────────────────────────────────────────────┐
│ HIBERNATE TRANSLATION                                    │
│                                                          │
│ JPQL → SQL (dialect-specific)                            │
│ ├─ Abstract entity references → table names             │
│ ├─ Property names → column names                        │
│ ├─ Operators → SQL operators                            │
│ └─ Generate PostgreSQL native SQL                       │
└────────────┬─────────────────────────────────────────────┘
             │
             ↓
┌──────────────────────────────────────────────────────────┐
│ CONNECTION POOL (HikariCP)                               │
│                                                          │
│ ├─ Borrow connection from pool                          │
│ ├─ Set isolation level & autocommit                     │
│ └─ Prepare for execution                                │
└────────────┬─────────────────────────────────────────────┘
             │
             ↓
┌──────────────────────────────────────────────────────────┐
│ EXECUTE AGAINST POSTGRESQL                               │
│                                                          │
│ PreparedStatement ps = conn.prepareStatement(sql);       │
│ ps.setParameter(1, value1);                              │
│ ps.setParameter(2, value2);                              │
│ ResultSet rs = ps.executeQuery();                        │
│ (or ps.executeUpdate() for INSERT/UPDATE/DELETE)         │
└────────────┬─────────────────────────────────────────────┘
             │
             ↓
┌──────────────────────────────────────────────────────────┐
│ PROCESS RESULTS                                          │
│                                                          │
│ For SELECT queries:                                      │
│ ├─ Iterate ResultSet rows                               │
│ ├─ Create entity instances                              │
│ ├─ Map column values to entity fields                   │
│ ├─ Handle relationships (FK → load related entities)    │
│ ├─ Add to Persistence Context                           │
│ └─ Return List/Optional to service                      │
│                                                          │
│ For INSERT/UPDATE/DELETE:                               │
│ ├─ Row count updated                                    │
│ ├─ Generated IDs returned (if INSERT)                   │
│ └─ Entity added/updated in Persistence Context          │
└────────────┬─────────────────────────────────────────────┘
             │
             ↓
┌──────────────────────────────────────────────────────────┐
│ RETURN TO SERVICE LAYER                                  │
│                                                          │
│ Entity(s) returned as:                                   │
│ ├─ T (single entity)                                    │
│ ├─ Optional<T> (possibly missing)                       │
│ ├─ List<T> (multiple entities)                          │
│ ├─ Page<T> (paginated results)                          │
│ └─ Custom DTO projections                               │
└──────────────────────────────────────────────────────────┘
```

---

## AURACONTROL REPOSITORY EXAMPLES

### Example 1: Derived Query (Simple)

```java
// UserRepository method
Optional<User> findByEmail(String email);

// Execution in Service:
@Transactional
public UserProfileResponse getCurrentUserProfile() {
    String currentUserEmail = SecurityContextHolder
            .getContext()
            .getAuthentication()
            .getName();
    
    // Call repository method
    Optional<User> userOpt = userRepository.findByEmail(currentUserEmail);
    User user = userOpt.orElseThrow(() → 
        new ResourceNotFoundException("User not found"));
    
    return UserProfileResponse.builder()
            .id(Math.toIntExact(user.getUserId()))
            .fullName(user.getName())
            .email(user.getEmail())
            .build();
}

// Behind the scenes:
// 1. Spring generates: SELECT u FROM User u WHERE u.email = :email
// 2. Hibernate translates: SELECT user_id, name, email, role, enabled, ... FROM users WHERE email = ?
// 3. Executes: SELECT * FROM users WHERE email = 'john@example.com'
// 4. PostgreSQL returns 1 row
// 5. Hibernate maps to User entity
// 6. Optional.of(user) returned
// 7. Service receives Optional with user
// 8. orElseThrow() throws exception if empty
// 9. DTO response created
```

### Example 2: Complex Derived Query (Multiple Conditions)

```java
// AppointmentRepository method
List<Appointment> findByCustomer_User_EmailAndStartTimeAfterAndStatusNotOrderByStartTimeAsc(
    String email,
    LocalDateTime startTime,
    String status
);

// Execution in Service:
@Transactional
public List<AppointmentHistoryDto> getUpcomingAppointments(String userEmail) {
    // Get appointments after now that aren't cancelled
    List<Appointment> upcoming = appointmentRepository
            .findByCustomer_User_EmailAndStartTimeAfterAndStatusNotOrderByStartTimeAsc(
                userEmail,
                LocalDateTime.now(),
                "CANCELLED"
            );
    
    // Convert to DTOs
    return upcoming.stream()
            .map(appt → AppointmentHistoryDto.builder()
                    .appointmentId(appt.getAppointmentId())
                    .startTime(appt.getStartTime())
                    .serviceName(appt.getService().getName())
                    .technicianName(appt.getTechnician().getUser().getName())
                    .build())
            .collect(Collectors.toList());
}

// Generated JPQL:
// SELECT a FROM Appointment a
// WHERE a.customer.user.email = :email
// AND a.startTime > :startTime
// AND a.status != :status
// ORDER BY a.startTime ASC

// Translated SQL:
// SELECT a.appointment_id, a.start_time, a.end_time, a.status, ...,
//        s.service_id, s.name, s.duration_minutes, ...,
//        t.technician_id, t.user_id, ...
// FROM appointment a
// JOIN customer c ON a.customer_id = c.customer_id
// JOIN users u ON c.user_id = u.user_id
// JOIN services s ON a.service_id = s.service_id
// JOIN technician t ON a.technician_id = t.technician_id
// WHERE u.email = 'john@example.com'
// AND a.start_time > CURRENT_TIMESTAMP
// AND a.status != 'CANCELLED'
// ORDER BY a.start_time ASC
```

### Example 3: Custom @Query (JPQL)

```java
// ServiceRepository method
@Query("SELECT u FROM User u " +
       "WHERE u.role = :role AND u.enabled = true")
List<User> findActiveUsersByRole(@Param("role") Role role);

// Execution:
@Transactional
public List<AdminDto> getActiveAdmins() {
    List<User> admins = userRepository
            .findActiveUsersByRole(Role.ADMIN);
    
    return admins.stream()
            .map(user → new AdminDto(user.getUserId(), user.getName()))
            .collect(Collectors.toList());
}

// Execution steps:
// 1. Query is defined, @Query found
// 2. Parameter substitution: :role = Role.ADMIN
// 3. JPQL generated (not from method name)
// 4. Translated to SQL:
//    SELECT u.user_id, u.name, u.email, u.role, u.enabled, ...
//    FROM users u
//    WHERE u.role = 'ADMIN' AND u.enabled = true
// 5. Executed against PostgreSQL
// 6. Results mapped to User entities
// 7. List<User> returned
// 8. Service maps to DTOs
```

### Example 4: @Query Native SQL (Function Call)

```java
// TechnicianRepository method
@Query(value = "SELECT * FROM get_available_technicians(:serviceId, CAST(:checkTime AS TIMESTAMP))",
       nativeQuery = true)
List<TechnicianOptionDto> findAvailableTechnicians(
    @Param("serviceId") Integer serviceId,
    @Param("checkTime") LocalDateTime checkTime
);

// Execution in Service:
@Transactional
public List<TechnicianOptionDto> getAvailableTechnicians(Integer serviceId) {
    // Direct call to PostgreSQL function
    List<TechnicianOptionDto> available = technicianRepository
            .findAvailableTechnicians(
                serviceId,
                LocalDateTime.now()
            );
    
    return available;
}

// Execution steps:
// 1. nativeQuery = true: Skip JPQL translation
// 2. Raw SQL used directly
// 3. Parameters bound: serviceId = 1, checkTime = '2025-01-15 14:30:00'
// 4. SQL executed:
//    SELECT * FROM get_available_technicians(1, '2025-01-15 14:30:00')
// 5. PostgreSQL function executes:
//    ├─ Finds technicians with required skill (serviceId)
//    ├─ Checks no conflicting appointments at checkTime
//    ├─ Checks no approved absence at checkTime
//    └─ Returns result set
// 6. Results mapped to TechnicianOptionDto objects
// 7. List<TechnicianOptionDto> returned
```

### Example 5: @Modifying Query (UPDATE)

```java
// UserRepository method
@Modifying
@Query("UPDATE User u SET u.password = :password WHERE u.userId = :id")
void updatePassword(@Param("id") Long id, @Param("password") String password);

// Execution in Service:
@Transactional
public void changePassword(Long userId, String newEncodedPassword) {
    // Repository method updates directly
    userRepository.updatePassword(userId, newEncodedPassword);
    
    // No entity object needed, no repository.save() needed
}

// Execution steps:
// 1. @Modifying detected: This is UPDATE, not SELECT
// 2. JPQL/SQL generated:
//    UPDATE users u SET u.password = :password WHERE u.user_id = :id
// 3. Parameters bound:
//    ├─ id = 1
//    └─ password = '$2a$10$...(bcrypt hashed)...'
// 4. SQL executed:
//    UPDATE users SET password = '...' WHERE user_id = 1
// 5. Rows affected: 1
// 6. Transaction commits
// 7. Changes persisted to database
```

### Example 6: Pagination

```java
// ServiceRepository method
List<Service> findByIsActiveTrue(Pageable pageable);

// Execution in Service:
@Transactional
public Page<ServiceDto> getServicesForBooking(int page, int size) {
    // Create pagination request
    Pageable pageable = PageRequest.of(page, size, Sort.by("name").ascending());
    
    // Repository automatically handles pagination
    Page<Service> services = serviceRepository
            .findByIsActiveTrue(pageable);
    
    // Convert to DTOs
    return services.map(service → ServiceDto.builder()
            .serviceId(service.getServiceId())
            .name(service.getName())
            .durationMinutes(service.getDurationMinutes())
            .price(service.getPrice())
            .build());
}

// Generated SQL (with LIMIT/OFFSET):
// SELECT s.service_id, s.name, s.duration_minutes, s.price, ...
// FROM services s
// WHERE s.is_active = true
// ORDER BY s.name ASC
// LIMIT 10 OFFSET 0

// Page object contains:
// ├─ content: List<Service> (10 items)
// ├─ totalElements: long (total count)
// ├─ totalPages: int (total pages)
// ├─ currentPageNumber: int (0-indexed)
// └─ ... other pagination info
```

---

## QUERY EXECUTION DEEP DIVE

### Caching & Query Plans

```
┌──────────────────────────────────────────────────────┐
│ QUERY PLAN CACHING                                   │
└──────────────────────────────────────────────────────┘

First execution:
1. SQL sent to PostgreSQL
2. PostgreSQL query planner analyzes:
   ├─ Available indexes
   ├─ Table sizes
   ├─ Statistics
   └─ Generates optimal query plan
3. Query plan cached in PostgreSQL
4. Query executed

Subsequent executions:
1. Cached query plan reused
2. Faster execution (no re-planning)
3. Bind variables: Only parameters change
4. Same plan, different data

Example:

First call:
SELECT * FROM appointment WHERE start_time > '2025-01-15 09:00'
Query plan: Seq scan or index scan? PostgreSQL decides

Second call:
SELECT * FROM appointment WHERE start_time > '2025-01-16 09:00'
Same plan reused! Only parameter '2025-01-16 09:00' differs
```

### Prepared Statements & Parameter Binding

```java
// What Hibernate does internally:

// Instead of string concatenation:
String email = "john@example.com";
String sql = "SELECT * FROM users WHERE email = '" + email + "'";
// ❌ VULNERABLE TO SQL INJECTION!

// Hibernate uses PreparedStatement:
String sql = "SELECT * FROM users WHERE email = ?";
PreparedStatement ps = connection.prepareStatement(sql);
ps.setString(1, "john@example.com");  // Safe parameter binding
ResultSet rs = ps.executeQuery();

// Benefits:
// ✅ SQL injection proof
// ✅ Database caches query plan
// ✅ Better performance
// ✅ Type-safe (type checking before execution)
```

### N+1 Query Problem

```java
// ❌ WRONG: Causes N+1 queries

@Transactional
public List<AppointmentDto> getAllAppointments() {
    List<Appointment> appointments = appointmentRepository.findAll();
    // Query 1: SELECT * FROM appointment (returns 100 appointments)
    
    return appointments.stream()
            .map(appt → {
                String customerName = appt.getCustomer().getName();
                // Query 2-101: SELECT * FROM customer WHERE customer_id = ? (100 queries!)
                
                String technicianName = appt.getTechnician().getUser().getName();
                // Query 102-201: SELECT * FROM technician ... (100 more queries!)
                // Query 202-301: SELECT * FROM users ... (100 more queries!)
                
                return new AppointmentDto(customerName, technicianName);
            })
            .collect(Collectors.toList());
}
// Total: 1 + 100 + 100 + 100 = 301 queries! 🔴 VERY SLOW

// ✅ SOLUTIONS:

// Solution 1: Use fetch = FetchType.EAGER in entity
@ManyToOne(fetch = FetchType.EAGER)  // Load immediately
private Customer customer;

// Solution 2: Use JOIN FETCH in @Query
@Query("SELECT a FROM Appointment a " +
       "JOIN FETCH a.customer " +
       "JOIN FETCH a.technician t " +
       "JOIN FETCH t.user")
List<Appointment> findAllWithDetails();

// Solution 3: Projections (select only needed fields)
@Query("SELECT new com.example.dto.AppointmentDto(" +
       "a.appointmentId, c.user.name, t.user.name) " +
       "FROM Appointment a " +
       "JOIN a.customer c " +
       "JOIN a.technician t")
List<AppointmentDto> findAllDtos();

// Result: 1 query instead of 301! ✅ VERY FAST
```

### Transaction Isolation & Locks

```
┌───────────────────────────────────────┐
│ ISOLATION LEVELS                      │
├───────────────────────────────────────┤
│ READ_UNCOMMITTED                      │
│ ├─ Dirty reads allowed (✗ avoid)      │
│ └─ Lowest isolation                   │
│                                       │
│ READ_COMMITTED (default)              │
│ ├─ No dirty reads                     │
│ ├─ Phantom reads possible             │
│ └─ Good balance                       │
│                                       │
│ REPEATABLE_READ                       │
│ ├─ No dirty or phantom reads          │
│ ├─ Slightly slower                    │
│ └─ Better for consistent reads        │
│                                       │
│ SERIALIZABLE (strictest)              │
│ ├─ All anomalies prevented            │
│ ├─ Slowest                            │
│ └─ Use for critical operations        │
└───────────────────────────────────────┘

PostgreSQL default: READ_COMMITTED
```

---

## PERFORMANCE CONSIDERATIONS

### Query Optimization Tips

```
1. USE PROPER INDEXES
   ├─ @Column(name="email")
   ├─ Add unique constraint: ALTER TABLE users ADD UNIQUE(email)
   ├─ Query: SELECT * FROM users WHERE email = 'x'
   ├─ Uses index → O(log n) instead of O(n)
   └─ Much faster for lookups

2. BATCH OPERATIONS
   ├─ Don't: for (i=1; i<=1000; i++) { repo.save(entity); }
   ├─ Do: repo.saveAll(entityList);  // Batches inserts
   └─ Much faster (1 SQL statement vs 1000)

3. AVOID LAZY LOADING OUTSIDE TRANSACTION
   ├─ Accessing lazy property outside @Transactional
   ├─ Throws: LazyInitializationException
   └─ Solution: Keep transaction open or use eager loading

4. USE PROJECTIONS INSTEAD OF FULL ENTITIES
   ├─ Need only name & email? Load only those fields
   ├─ Reduces network bandwidth
   ├─ Faster mapping
   └─ Custom DTOs or interface projections

5. PAGINATION FOR LARGE RESULT SETS
   ├─ Don't: findAll() on 1 million rows
   ├─ Do: findAll(PageRequest.of(0, 100))
   ├─ Load chunks instead of all at once
   └─ Better memory usage

6. EAGER VS LAZY LOADING
   ├─ Eager: Load everything upfront (1 query with JOINs)
   ├─ Lazy: Load only when accessed (multiple queries)
   ├─ Choose based on usage pattern
   └─ Avoid accessing lazy properties in loops
```

### SQL Execution Monitoring

```java
// Enable Hibernate SQL logging in application.yaml
logging:
  level:
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE

// Output shows:
// Hibernate: SELECT appointment0_.appointment_id as appointment_id1_0_0_, ...
// Hibernate: binding parameter [1] as [TIMESTAMP] - [java.time.LocalDateTime@8f1c3c6]

// Use p6spy for SQL logging without code changes:
// gradle: compile 'p6spy:p6spy:1.6.3'
// Logs all SQL with execution time
```

---

## SUMMARY: REPOSITORY LAYER COMMUNICATION

### Key Points

1. **JPA Repository**: Auto-generates implementations from interfaces
2. **Query Generation**: Method names or @Query annotations translated to SQL
3. **EntityManager**: Manages entity lifecycle and Persistence Context
4. **Persistence Context**: 1st-level cache per transaction
5. **Lazy Loading**: Related entities loaded on-demand (can cause problems)
6. **SQL Translation**: JPQL/Derived queries converted to database-specific SQL
7. **Parameter Binding**: Safe, cached query plans
8. **Dirty Checking**: Automatic detection of entity changes
9. **Transaction Boundaries**: Changes flushed and committed at transaction end

### Repository → Database Flow

```
Service calls repository.findById(1)
    ↓
Spring Data JPA intercepts
    ↓
Query generated (if needed)
    ↓
Check Persistence Context (cache)
    ↓
If not cached:
    ├─ Hibernate translates to SQL
    ├─ Connection obtained from pool
    ├─ SQL executed against PostgreSQL
    └─ ResultSet mapped to entities
    ↓
Add entities to Persistence Context
    ↓
Return to service
```

### Next Documents

- **database.md** - Deep dive into EntityManager and persistence
- **dataflow.md** - Complete bidirectional data flow
- **workflow.md** - End-to-end request processing workflow

