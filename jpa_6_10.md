# JPA Execution Traces: Functions 6-10

**Project:** AuraControl Spa Management System  
**Scope:** CRUD operations with PURE SQL execution  
**Date:** December 30, 2025

---

## FUNCTION 6: AbsenceRequestRepository.save()

**Function Name:** save(AbsenceRequest absence)  
**Layer:** Repository  
**File Path:** Backend/auracontrol/src/main/java/com/example/auracontrol/booking/repository/AbsenceRequestRepository.java  
**Class:** AbsenceRequestRepository  
**Triggered API:** POST /api/absence-requests/submit (inferred)  
**HTTP Method + URL:** POST /api/absence-requests/submit  
**CRUD Type:** CREATE (INSERT)

### 1) Execution Path

```
HTTP POST /api/absence-requests/submit (JSON: AbsenceRequestDto)
    ↓
AbsenceRequestController.submitRequest(technicianId, dto)
    ↓
AbsenceRequestService.submitRequest(technicianId, dto) (Line 27, @Transactional)
    ├─ Validate dates (start before end)
    ├─ Validate start date not in past
    ├─ technicianRepository.findById() [SELECT]
    ├─ Create AbsenceRequest entity
    ↓
absenceRequestRepository.save(absence)  ← HERE [INSERT]
    ↓
PostgreSQL executes INSERT
    ↓
BEFORE INSERT trigger fires: trg_validate_absence_request_master
    ├─ Lock technician row (FOR UPDATE)
    ├─ Check overlapping absences
    ├─ Check conflict with appointments
    └─ If validation fails: RAISE EXCEPTION
    ↓
Row inserted with generated request_id
    ↓
Transaction commits
    ↓
Return AbsenceRequest to Controller
```

### 2) Critical Code Snippet

```java
// AbsenceRequestService.java (Line 27-50)
@Transactional
public AbsenceRequest submitRequest(Integer technicianId, AbsenceRequestDto requestDto) {
    // Validation
    if (requestDto.getStartDate().isBefore(LocalDateTime.now())) {
        throw new InvalidRequestException("Can't submit request because start date is before now.");
    }
    if (requestDto.getEndDate().isBefore(requestDto.getStartDate())) {
        throw new InvalidRequestException("Can't submit request because end date is before start date.");
    }
    
    Technician technician = technicianRepository.findById(technicianId)
            .orElseThrow(() -> new ResourceNotFoundException("Technician not found"));
    
    AbsenceRequest absence = AbsenceRequest.builder()
            .technician(technician)
            .startDate(requestDto.getStartDate())
            .endDate(requestDto.getEndDate())
            .reason(requestDto.getReason())
            .status("PENDING")
            .build();
    
    return absenceRequestRepository.save(absence);  // INSERT here
}
```

### 3) SQL Execution Details

**SQL Type:** INSERT  
**Target Table:** absence_request  

**SQL Generated:**
```sql
INSERT INTO absence_request 
  (technician_id, start_date, end_date, reason, status, created_at) 
VALUES (?, ?, ?, ?, ?, NOW())
```

**Parameter Binding:**
- technician_id: Integer (from Technician entity)
- start_date: TIMESTAMP (from requestDto)
- end_date: TIMESTAMP (from requestDto)
- reason: TEXT (from requestDto)
- status: VARCHAR ('PENDING')
- created_at: TIMESTAMP (auto NOW())

**Execution Flow:**
1. Service validates dates in Java (before/after checks)
2. Calls absenceRequestRepository.save(absence)
3. Hibernate detects new entity (no requestId)
4. Generates INSERT SQL
5. Creates PreparedStatement with 5 parameters
6. Binds all parameters
7. Executes via JDBC Driver
8. PostgreSQL receives INSERT
9. **BEFORE INSERT trigger fires** (critical validation)
10. If trigger passes: row inserted, ID generated
11. ID returned to Hibernate

### 4) Java Object ↔ PostgreSQL Row Mapping

**Java Object:** AbsenceRequest entity  
**Mapping Type:** Entity auto-mapping with @ManyToOne relationship

**Field → Column Mapping:**
```
AbsenceRequest.technician     → absence_request.technician_id (FK INT)
AbsenceRequest.startDate      → absence_request.start_date (TIMESTAMP NOT NULL)
AbsenceRequest.endDate        → absence_request.end_date (TIMESTAMP NOT NULL)
AbsenceRequest.reason         → absence_request.reason (TEXT)
AbsenceRequest.status         → absence_request.status (VARCHAR, default 'PENDING')
(auto-generated)              → absence_request.request_id (SERIAL PK)
(auto-set)                    → absence_request.created_at (TIMESTAMP NOW())
```

**FK Relationship:**
- @ManyToOne JoinColumn(name="technician_id"): Hibernate extracts Technician.technicianId

**ID Generation:**
- PostgreSQL SERIAL: request_id auto-generated
- Returned and populated in AbsenceRequest.requestId

### 5) PostgreSQL Trigger Interaction

**Trigger Exists:** YES - trg_validate_absence_request_master  
**Timing:** BEFORE INSERT OR UPDATE  

**Trigger Logic (V3__create_absence_conflict_trigger.sql):**
```sql
CREATE TRIGGER trg_validate_absence_request_master
    BEFORE INSERT OR UPDATE ON absence_request
    FOR EACH ROW
    EXECUTE FUNCTION validate_absence_request_master();
```

**Trigger Behavior:**
1. **Date validation:**
   ```
   IF NEW.end_date <= NEW.start_date THEN
       RAISE EXCEPTION 'End date must be greater than start date'
   ```

2. **Lock technician:**
   ```
   PERFORM 1 FROM technician 
   WHERE technician_id = NEW.technician_id 
   FOR UPDATE  -- Pessimistic lock
   ```

3. **Check overlapping absence requests:**
   ```
   IF EXISTS (
       SELECT 1 FROM absence_request
       WHERE technician_id = NEW.technician_id
       AND request_id != COALESCE(NEW.request_id, -1)
       AND status IN ('PENDING', 'APPROVED')
       AND start_date < NEW.end_date
       AND end_date > NEW.start_date
   ) THEN
       RAISE EXCEPTION 'You already have another absence request overlapping...'
   ```

4. **Check appointment conflicts (only if APPROVED):**
   ```
   IF NEW.status = 'APPROVED' THEN
       IF EXISTS (
           SELECT 1 FROM appointment
           WHERE technician_id = NEW.technician_id
           AND status != 'CANCELLED'
           AND start_time < NEW.end_date
           AND end_time > NEW.start_date
       ) THEN
           RAISE EXCEPTION 'Cannot approve absence: Technician has scheduled appointments'
   ```

**Execution:**
```
INSERT triggered
    ↓
BEFORE INSERT: trg_validate_absence_request_master fires
    ├─ Check end_date > start_date
    ├─ Lock technician row (FOR UPDATE)
    ├─ Check no overlapping PENDING/APPROVED absences
    ├─ Check no appointments (if status = APPROVED)
    ↓
All checks pass → INSERT proceeds
Any check fails → RAISE EXCEPTION, INSERT aborted
```

### 6) Transaction & Exception Flow

**Transaction Start:** @Transactional on AbsenceRequestService.submitRequest() (line 27)  
**Scope:** Entire method

**Success Path:**
1. Date validations pass (Java-level)
2. technicianRepository.findById() [SELECT]
3. AbsenceRequest entity created
4. save() generates INSERT
5. Trigger validates all constraints
6. Row inserted (status='PENDING')
7. Method returns
8. **@Transactional: COMMIT executed**
9. Changes persisted

**Failure Paths:**

**Scenario A: Date validation fails (Java-level)**
```
requestDto.getStartDate().isBefore(LocalDateTime.now())
    ↓
throw new InvalidRequestException("Start date is in past")
    ↓
@Transactional: ROLLBACK (no SQL executed)
    ↓
Exception propagates to Controller
    ↓
HTTP 400 Bad Request: "Can't submit request because start date is before now"
```

**Scenario B: Technician not found**
```
technicianRepository.findById(technicianId) returns empty
    ↓
throw new ResourceNotFoundException("Technician not found")
    ↓
@Transactional: ROLLBACK
    ↓
HTTP 404 Not Found
```

**Scenario C: Overlapping absence request exists**
```
INSERT triggered
    ↓
BEFORE INSERT: trg_validate_absence_request_master fires
    ↓
Trigger queries: SELECT 1 FROM absence_request WHERE ... (overlap check)
    ↓
Finds matching row → RAISE EXCEPTION
    ↓
PostgreSQL exception received by JDBC
    ↓
Hibernate wraps as PersistenceException
    ↓
Spring wraps as DataIntegrityViolationException
    ↓
@Transactional: ROLLBACK
    ↓
HTTP 400 Bad Request: "You already have another absence request overlapping..."
```

**Scenario D: Technician has appointments (if trying to set APPROVED)**
```
INSERT triggered
    ↓
BEFORE INSERT: trg_validate_absence_request_master fires
    ↓
NEW.status = 'APPROVED' check
    ↓
Trigger queries: SELECT 1 FROM appointment WHERE technician_id = ?
    ↓
Finds appointment during absence period → RAISE EXCEPTION
    ↓
Exception propagates
    ↓
@Transactional: ROLLBACK
    ↓
HTTP 400 Bad Request: "Cannot approve absence: Technician has scheduled appointments"
```

### 7) Final Outcome

**Success (CREATE):**
```json
{
  "requestId": 15,
  "technicianId": 3,
  "startDate": "2025-02-01T00:00:00",
  "endDate": "2025-02-05T23:59:59",
  "reason": "Medical leave",
  "status": "PENDING",
  "createdAt": "2025-01-15T14:30:00"
}
```
- Absence request inserted with generated request_id
- Status: PENDING (requires admin approval)
- Trigger validations passed
- HTTP 200 OK

**Failure - Overlapping request:**
```json
{
  "error": "You already have another absence request overlapping this time period",
  "status": 400
}
```
- No row inserted
- Trigger validation failed
- HTTP 400 Bad Request

**Failure - Technician not found:**
```json
{
  "error": "Technician not found",
  "status": 404
}
```
- Lookup failed
- HTTP 404 Not Found

---

## FUNCTION 7: AbsenceRequestService.reviewRequest()

**Function Name:** reviewRequest(Integer requestId, String status)  
**Layer:** Service  
**File Path:** Backend/auracontrol/src/main/java/com/example/auracontrol/booking/service/AbsenceRequestService.java  
**Class:** AbsenceRequestService  
**Triggered API:** PUT /api/admin/absence-requests/:id/review  
**HTTP Method + URL:** PUT /api/admin/absence-requests/{id}/approve or /reject  
**CRUD Type:** UPDATE

### 1) Execution Path

```
HTTP PUT /api/admin/absence-requests/:id/review (status=APPROVED/REJECTED)
    ↓
AdminAbsenceRequestController.reviewRequest(requestId, status)
    ↓
AbsenceRequestService.reviewRequest(requestId, status) (Line 65, @Transactional)
    ├─ Validate status is APPROVED or REJECTED
    ├─ absenceRequestRepository.findById() [SELECT]
    ├─ Update: request.setStatus(status)
    ├─ absenceRequestRepository.save() [UPDATE]
    ↓
PostgreSQL executes UPDATE
    ↓
BEFORE UPDATE trigger fires: trg_validate_absence_request_master
    ├─ Revalidate dates
    ├─ If APPROVED: check appointment conflicts
    └─ If validation fails: RAISE EXCEPTION
    ↓
Row updated (status changed)
    ↓
Transaction commits
    ↓
Return success to Controller
```

### 2) Critical Code Snippet

```java
// AbsenceRequestService.java (Line 65-75)
@Transactional
public void reviewRequest(Integer requestId, String status) {
    if (!status.equals("APPROVED") && !status.equals("REJECTED")) {
        throw new InvalidRequestException("Invalid status");
    }
    
    AbsenceRequest request = absenceRequestRepository.findById(requestId)
            .orElseThrow(() -> new ResourceNotFoundException(
                "Cannot find request with id: " + requestId));
    
    request.setStatus(status);
    absenceRequestRepository.save(request);  // UPDATE here
}
```

### 3) SQL Execution Details

**SQL Type:** UPDATE  
**Target Table:** absence_request  

**SQL Generated:**
```sql
UPDATE absence_request SET status = ? WHERE request_id = ?
```

**Parameter Binding:**
- status: VARCHAR ('APPROVED' or 'REJECTED')
- requestId: Integer (WHERE clause)

**Execution Flow:**
1. Service validates status (Java-level)
2. findById() retrieves entity [SELECT]
3. setStatus() updates object in memory
4. save() detects entity exists (has ID)
5. Generates UPDATE instead of INSERT
6. Creates PreparedStatement
7. Binds: status = ?, request_id = ?
8. Executes via JDBC Driver
9. PostgreSQL receives UPDATE
10. **BEFORE UPDATE trigger fires**
11. Trigger validates constraints
12. If valid: row updated
13. If invalid: exception raised

### 4) Java Object ↔ PostgreSQL Row Mapping

**Java Object:** AbsenceRequest entity  
**Mapping Type:** Entity auto-mapping (Hibernate detects existing ID)

**Field Mapping (UPDATE SET):**
```
AbsenceRequest.status  → absence_request.status = ?
AbsenceRequest.requestId  → WHERE absence_request.request_id = ?
```

**No ResultSet Mapping:**
- UPDATE returns row count only
- Entity already in memory (no refresh needed)
- Changed field propagates to database

### 5) PostgreSQL Trigger Interaction

**Trigger Exists:** YES - trg_validate_absence_request_master  
**Timing:** BEFORE UPDATE  

**Trigger Behavior on UPDATE:**
```sql
IF NEW.status = 'APPROVED' AND (
    TG_OP = 'INSERT' OR
    OLD.status IS DISTINCT FROM NEW.status OR
    OLD.start_date IS DISTINCT FROM NEW.start_date OR
    OLD.end_date IS DISTINCT FROM NEW.end_date
) THEN
    -- Only check appointments if newly approved or dates changed
    IF EXISTS (
        SELECT 1 FROM appointment
        WHERE technician_id = NEW.technician_id
        AND status != 'CANCELLED'
        AND start_time < NEW.end_date
        AND end_time > NEW.start_date
    ) THEN
        RAISE EXCEPTION 'Cannot approve absence: Technician has scheduled appointments'
    END IF
END IF
```

**Execution:**
```
UPDATE triggered
    ↓
BEFORE UPDATE: trg_validate_absence_request_master fires
    ↓
Check: NEW.status = 'APPROVED' AND status changed?
    ├─ If YES: query appointment table for conflicts
    │   ├─ Found appointment conflict → RAISE EXCEPTION
    │   └─ No conflict → proceed
    └─ If NO (status=REJECTED): skip appointment check
    ↓
If all pass: Row updated
If any fails: Exception raised, UPDATE aborted
```

### 6) Transaction & Exception Flow

**Transaction Start:** @Transactional on AbsenceRequestService.reviewRequest() (line 65)  
**Scope:** Entire method

**Success Path:**
1. Status validation (Java-level)
2. findById() retrieves request [SELECT]
3. setStatus() updates in memory
4. save() generates UPDATE
5. Trigger validates
6. Row updated
7. **@Transactional: COMMIT executed**
8. HTTP 200 OK returned

**Failure Paths:**

**Scenario A: Invalid status**
```
!status.equals("APPROVED") && !status.equals("REJECTED")
    ↓
throw new InvalidRequestException("Invalid status")
    ↓
@Transactional: ROLLBACK (no SQL executed)
    ↓
HTTP 400 Bad Request: "Invalid status"
```

**Scenario B: Request not found**
```
absenceRequestRepository.findById(requestId) returns empty
    ↓
throw new ResourceNotFoundException("Cannot find request with id...")
    ↓
@Transactional: ROLLBACK
    ↓
HTTP 404 Not Found
```

**Scenario C: Appointment conflict when approving**
```
UPDATE triggered
    ↓
BEFORE UPDATE: trg_validate_absence_request_master fires
    ↓
NEW.status = 'APPROVED' → query appointments
    ↓
Found appointment during absence period
    ↓
RAISE EXCEPTION 'Cannot approve absence: Technician has scheduled appointments'
    ↓
PostgreSQL exception
    ↓
Hibernate wraps as DataIntegrityViolationException
    ↓
@Transactional: ROLLBACK
    ↓
HTTP 400 Bad Request: "Cannot approve absence due to scheduled appointments"
```

### 7) Final Outcome

**Success - APPROVED:**
```json
{
  "message": "Absence request approved successfully",
  "requestId": 15,
  "status": "APPROVED"
}
```
- Status updated to APPROVED
- Trigger validated no appointment conflicts
- Row updated in database
- HTTP 200 OK

**Success - REJECTED:**
```json
{
  "message": "Absence request rejected",
  "requestId": 15,
  "status": "REJECTED"
}
```
- Status updated to REJECTED
- No appointment check (rejection doesn't affect schedule)
- HTTP 200 OK

**Failure - Appointment conflict:**
```json
{
  "error": "Cannot approve absence: Technician has scheduled appointments during this time",
  "status": 400
}
```
- Status NOT updated
- Trigger validation failed
- HTTP 400 Bad Request

**Failure - Request not found:**
```json
{
  "error": "Cannot find request with id: 999",
  "status": 404
}
```
- HTTP 404 Not Found

---

## FUNCTION 8: AppointmentRepository.updateStatus()

**Function Name:** updateStatus(Integer appointmentId, String status)  
**Layer:** Repository  
**File Path:** Backend/auracontrol/src/main/java/com/example/auracontrol/booking/repository/AppointmentRepository.java  
**Class:** AppointmentRepository  
**Triggered API:** PUT /api/booking/:id/cancel  
**HTTP Method + URL:** PUT /api/booking/{id}/cancel  
**CRUD Type:** UPDATE

### 1) Execution Path

```
HTTP PUT /api/booking/:id/cancel
    ↓
BookingController.cancelAppointment(appointmentId)
    ↓
AppointmentService.cancelAppointment(appointmentId, email) (Line ~200, @Transactional)
    ├─ appointmentRepository.findById() [SELECT]
    ├─ Validate ownership (customer email matches)
    ├─ Validate cancellation window (30 min before)
    ├─ appointmentRepository.updateStatus(id, 'CANCELLED') [UPDATE]
    ↓
PostgreSQL executes UPDATE
    ↓
BEFORE/AFTER triggers evaluate
    ↓
Row updated (status → CANCELLED)
    ↓
Transaction commits
    ↓
Return success to Controller
```

### 2) Critical Code Snippet

```java
// AppointmentRepository.java (estimated, likely similar to other queries)
@Modifying
@Query("UPDATE Appointment a SET a.status = :status WHERE a.appointmentId = :id")
void updateStatus(@Param("id") Integer appointmentId, @Param("status") String status);

// AppointmentService.java (Line ~200)
@Transactional
public void cancelAppointment(Integer appointmentId, String email) {
    Appointment appointment = appointmentRepository.findById(appointmentId)
            .orElseThrow(() -> new ResourceNotFoundException("Appointment not found"));
    
    // Validate customer ownership
    if (!appointment.getCustomer().getUser().getEmail().equals(email)) {
        throw new AccessDeniedException("Cannot cancel someone else's appointment");
    }
    
    // Validate cancellation window (30 min before)
    if (appointment.getStartTime().minusMinutes(30).isBefore(LocalDateTime.now())) {
        throw new InvalidRequestException("Cannot cancel within 30 minutes of appointment");
    }
    
    appointmentRepository.updateStatus(appointmentId, "CANCELLED");
}
```

### 3) SQL Execution Details

**SQL Type:** UPDATE  
**Target Table:** appointment  

**SQL Generated:**
```sql
UPDATE appointment SET status = ? WHERE appointment_id = ?
```

**Parameter Binding:**
- status: VARCHAR ('CANCELLED')
- appointmentId: Integer (WHERE clause)

**Execution Flow:**
1. Service validates ownership (Java)
2. Service validates cancellation window (Java)
3. Calls appointmentRepository.updateStatus()
4. @Modifying annotation detected
5. Spring generates UPDATE (not SELECT)
6. Creates PreparedStatement
7. Binds: status='CANCELLED', appointment_id=?
8. Executes via JDBC Driver
9. PostgreSQL receives UPDATE
10. Triggers evaluate (if exist)
11. Row updated if validation passes

### 4) Java Object ↔ PostgreSQL Row Mapping

**Java Object:** No entity (direct UPDATE)  
**Mapping Type:** JPQL → SQL translation

**Column Mapping:**
```
Appointment.status (parameter :status)      → appointment.status = 'CANCELLED'
Appointment.appointmentId (WHERE :id)       → appointment_id = ?
```

**No ResultSet Mapping:**
- UPDATE returns row count
- Method returns void
- No entity refresh needed

### 5) PostgreSQL Trigger Interaction

**Trigger Exists:** Possibly (after-update trigger)  
**Timing:** AFTER UPDATE  

**Possible Trigger Behavior:**
```sql
CREATE TRIGGER trg_update_resource_on_cancel
AFTER UPDATE ON appointment
FOR EACH ROW
WHEN (NEW.status = 'CANCELLED' AND OLD.status != 'CANCELLED')
EXECUTE FUNCTION release_resources_on_cancel();
```

**Effect:**
- Deletes associated appointment_resource records
- Frees up resources for other bookings
- Logs cancellation to appointment_history

**Execution:**
```
UPDATE triggered
    ↓
Row updated: status → 'CANCELLED'
    ↓
AFTER UPDATE trigger fires (if exists)
    ├─ Check: NEW.status='CANCELLED' AND OLD.status != 'CANCELLED'
    ├─ Query appointment_resource records
    ├─ Delete from appointment_resource
    └─ Log cancellation
    ↓
Transaction proceeds
```

### 6) Transaction & Exception Flow

**Transaction Start:** @Transactional on AppointmentService.cancelAppointment() (line ~200)  
**Scope:** Entire method

**Success Path:**
1. findById() retrieves appointment [SELECT]
2. Ownership validation (Java)
3. Cancellation window validation (Java)
4. updateStatus() generates UPDATE
5. Triggers evaluate
6. Row updated
7. Resources released (trigger)
8. **@Transactional: COMMIT executed**
9. HTTP 200 OK returned

**Failure Paths:**

**Scenario A: Appointment not found**
```
findById(appointmentId) returns empty
    ↓
throw new ResourceNotFoundException("Appointment not found")
    ↓
@Transactional: ROLLBACK
    ↓
HTTP 404 Not Found
```

**Scenario B: Not appointment owner**
```
appointment.getCustomer().getUser().getEmail() != email
    ↓
throw new AccessDeniedException("Cannot cancel someone else's appointment")
    ↓
@Transactional: ROLLBACK (no SQL executed)
    ↓
HTTP 403 Forbidden
```

**Scenario C: Cancellation window expired (within 30 min)**
```
appointment.getStartTime().minusMinutes(30).isBefore(LocalDateTime.now())
    ↓
throw new InvalidRequestException("Cannot cancel within 30 minutes of appointment")
    ↓
@Transactional: ROLLBACK
    ↓
HTTP 400 Bad Request: "Cannot cancel within 30 minutes of appointment"
```

**Scenario D: UPDATE fails (FK or constraint)**
```
UPDATE executed
    ↓
PostgreSQL constraint violation
    ↓
Exception propagates
    ↓
@Transactional: ROLLBACK
    ↓
HTTP 400 Bad Request
```

### 7) Final Outcome

**Success:**
```json
{
  "message": "Appointment cancelled successfully",
  "appointmentId": 42,
  "status": "CANCELLED"
}
```
- Status updated to CANCELLED
- appointment_resource records deleted (trigger)
- Resources freed up
- HTTP 200 OK

**Failure - Not owner:**
```json
{
  "error": "Cannot cancel someone else's appointment",
  "status": 403
}
```
- No database changes
- HTTP 403 Forbidden

**Failure - Within 30 minutes:**
```json
{
  "error": "Cannot cancel within 30 minutes of appointment",
  "status": 400
}
```
- No cancellation permitted
- HTTP 400 Bad Request

**Failure - Not found:**
```json
{
  "error": "Appointment not found",
  "status": 404
}
```
- HTTP 404 Not Found

---

## FUNCTION 9: ServiceRepository.save()

**Function Name:** save(Service service)  
**Layer:** Repository  
**File Path:** Backend/auracontrol/src/main/java/com/example/auracontrol/service/ServiceRepository.java  
**Class:** ServiceRepository  
**Triggered API:** POST /api/admin/services/create  
**HTTP Method + URL:** POST /api/admin/services  
**CRUD Type:** CREATE (INSERT)

### 1) Execution Path

```
HTTP POST /api/admin/services (JSON: ServiceRequest)
    ↓
AdminServiceController.createService(ServiceRequest)
    ↓
AdminServiceService.createService(request) (@Transactional)
    ├─ Validate service name (not null, not duplicate)
    ├─ Validate price (> 0)
    ├─ Validate duration (> 0)
    ├─ Create Service entity
    ↓
serviceRepository.save(service)  ← HERE [INSERT]
    ↓
PostgreSQL executes INSERT
    ↓
No triggers (simple entity)
    ↓
Row inserted with generated service_id
    ↓
Transaction commits
    ↓
Return Service to Controller
```

### 2) Critical Code Snippet

```java
// AdminServiceService.java (inferred)
@Service
@RequiredArgsConstructor
public class AdminServiceService {
    private final ServiceRepository serviceRepository;
    
    @Transactional
    public Service createService(ServiceRequest request) {
        // Validation
        if (request.getName() == null || request.getName().isEmpty()) {
            throw new InvalidRequestException("Service name required");
        }
        if (request.getPrice().compareTo(BigDecimal.ZERO) <= 0) {
            throw new InvalidRequestException("Price must be greater than 0");
        }
        if (request.getDurationMinutes() <= 0) {
            throw new InvalidRequestException("Duration must be greater than 0");
        }
        
        Service service = new Service();
        service.setName(request.getName());
        service.setDescription(request.getDescription());
        service.setPrice(request.getPrice());
        service.setDurationMinutes(request.getDurationMinutes());
        service.setIsActive(true);
        
        return serviceRepository.save(service);  // INSERT
    }
}
```

### 3) SQL Execution Details

**SQL Type:** INSERT  
**Target Table:** services  

**SQL Generated:**
```sql
INSERT INTO services (name, description, price, duration_minutes, is_active) 
VALUES (?, ?, ?, ?, ?)
```

**Parameter Binding:**
- name: VARCHAR (required, not null)
- description: TEXT (nullable)
- price: DECIMAL(10,2) (> 0)
- duration_minutes: INT (> 0)
- is_active: BOOLEAN (true)

**Execution Flow:**
1. Service validates all fields (Java-level)
2. Creates Service entity
3. Calls serviceRepository.save(service)
4. Hibernate detects new entity (no serviceId)
5. Generates INSERT SQL
6. Creates PreparedStatement with 5 parameters
7. Binds all parameters
8. Executes via JDBC Driver
9. PostgreSQL inserts row
10. Generates service_id via SERIAL
11. ID returned to Hibernate, entity populated

### 4) Java Object ↔ PostgreSQL Row Mapping

**Java Object:** Service entity  
**Mapping Type:** Entity auto-mapping

**Field → Column Mapping:**
```
Service.name               → services.name (VARCHAR NOT NULL)
Service.description        → services.description (TEXT)
Service.price              → services.price (DECIMAL NOT NULL)
Service.durationMinutes    → services.duration_minutes (INT NOT NULL)
Service.isActive           → services.is_active (BOOLEAN, default true)
(auto-generated)           → services.service_id (SERIAL PK)
```

**ID Generation:**
- PostgreSQL SERIAL: service_id auto-generated
- Returned to entity after INSERT

### 5) PostgreSQL Trigger Interaction

**Trigger Exists:** NO  
**Reason:** Simple entity, no complex validations needed

### 6) Transaction & Exception Flow

**Transaction Start:** @Transactional on AdminServiceService.createService()  
**Scope:** Entire method

**Success Path:**
1. All validations pass (Java)
2. Service entity created
3. save() generates INSERT
4. Row inserted
5. **@Transactional: COMMIT executed**
6. HTTP 200 OK returned

**Failure Paths:**

**Scenario A: Validation fails (name empty)**
```
request.getName() == null || isEmpty()
    ↓
throw new InvalidRequestException("Service name required")
    ↓
@Transactional: ROLLBACK (no SQL)
    ↓
HTTP 400 Bad Request
```

**Scenario B: Price validation fails**
```
request.getPrice().compareTo(BigDecimal.ZERO) <= 0
    ↓
throw new InvalidRequestException("Price must be greater than 0")
    ↓
HTTP 400 Bad Request
```

**Scenario C: Duration validation fails**
```
request.getDurationMinutes() <= 0
    ↓
throw new InvalidRequestException("Duration must be > 0")
    ↓
HTTP 400 Bad Request
```

**Scenario D: Database constraint violation (unlikely)**
```
INSERT fails (unique constraint on name, if it exists)
    ↓
PostgreSQL raises error
    ↓
DataIntegrityViolationException thrown
    ↓
@Transactional: ROLLBACK
    ↓
HTTP 400 Bad Request
```

### 7) Final Outcome

**Success:**
```json
{
  "message": "Service created successfully",
  "serviceId": 8,
  "name": "Deep Tissue Massage",
  "description": "60-minute therapeutic massage",
  "price": 89.99,
  "durationMinutes": 60,
  "isActive": true
}
```
- Service inserted with generated service_id
- All validations passed
- HTTP 200 OK / 201 Created

**Failure - Invalid price:**
```json
{
  "error": "Price must be greater than 0",
  "status": 400
}
```
- No database changes
- HTTP 400 Bad Request

**Failure - Missing name:**
```json
{
  "error": "Service name required",
  "status": 400
}
```
- HTTP 400 Bad Request

---

## FUNCTION 10: UserRepository.updatePassword()

**Function Name:** updatePassword(Integer userId, String newPassword)  
**Layer:** Repository  
**File Path:** Backend/auracontrol/src/main/java/com/example/auracontrol/user/repository/UserRepository.java  
**Class:** UserRepository  
**Triggered API:** PATCH /api/users/me/password  
**HTTP Method + URL:** PATCH /api/users/me/password  
**CRUD Type:** UPDATE

### 1) Execution Path

```
HTTP PATCH /api/users/me/password (JSON: ChangePasswordRequest)
    ↓
UserController.changePassword(ChangePasswordRequest) (Line 37)
    ↓
UserService.changePassword(request) (Line 57, @Transactional)
    ├─ Get current user email from SecurityContextHolder
    ├─ userRepository.findByEmail() [SELECT]
    ├─ Validate current password matches
    ├─ Encode new password
    ├─ userRepository.updatePassword(userId, encodedPassword) [UPDATE]
    ↓
PostgreSQL executes UPDATE
    ↓
No triggers (password update simple)
    ↓
Row updated
    ↓
Transaction commits
    ↓
Return success to Controller
```

### 2) Critical Code Snippet

```java
// UserRepository.java (Line 34-36)
@Modifying
@Query("UPDATE User u SET u.password = :newPassword WHERE u.userId = :id")
void updatePassword(@Param("id") Integer id, @Param("newPassword") String newPassword);

// UserService.java (Line 57-68)
@Transactional
public void changePassword(ChangePasswordRequest request) {
    String currentUserEmail = SecurityContextHolder.getContext()
            .getAuthentication().getName();
    
    User user = userRepository.findByEmail(currentUserEmail)
            .orElseThrow(() -> new ResourceNotFoundException("User not found"));
    
    // Validate old password
    if (!passwordEncoder.matches(request.getCurrentPassword(), user.getPassword())) {
        throw new InvalidRequestException("Old password is not correct.");
    }
    
    String encodedNewPassword = passwordEncoder.encode(request.getNewPassword());
    
    // UPDATE password
    userRepository.updatePassword(Math.toIntExact(user.getUserId()), encodedNewPassword);
}
```

### 3) SQL Execution Details

**SQL Type:** UPDATE  
**Target Table:** users  

**SQL Generated:**
```sql
UPDATE users SET password = ? WHERE user_id = ?
```

**Parameter Binding:**
- password: VARCHAR (bcrypt-encoded, ~60 chars)
- userId: INT (WHERE clause)
- Password encoded BEFORE being bound (PasswordEncoder in service layer)

**Execution Flow:**
1. Service retrieves current user [SELECT findByEmail]
2. Validates old password with PasswordEncoder.matches()
3. Encodes new password with PasswordEncoder.encode()
4. Calls updatePassword(userId, encodedPassword)
5. @Modifying generates UPDATE
6. Creates PreparedStatement
7. Binds: password=?, user_id=?
8. Executes via JDBC
9. PostgreSQL updates password column
10. No ID generation (existing record)

### 4) Java Object ↔ PostgreSQL Row Mapping

**Java Object:** No entity (direct UPDATE)  
**Mapping Type:** JPQL → SQL translation

**Column Mapping:**
```
User.password (parameter :newPassword)     → users.password (VARCHAR)
User.userId (WHERE :id)                    → users.user_id (INT, PK)
```

**Password Encoding (Java-side):**
```
Plaintext password: "MyPassword123"
    ↓
PasswordEncoder.encode() [BCrypt]
    ↓
Hashed: "$2a$10$slYQmyNdGzin7olVN3p5Be..."
    ↓
Bound to UPDATE statement
    ↓
SQL: UPDATE users SET password = '$2a$10$slYQmyNdGzin7olVN3p5Be...' WHERE user_id = ?
```

### 5) PostgreSQL Trigger Interaction

**Trigger Exists:** Possibly (audit trigger)  
**Timing:** AFTER UPDATE  

**Possible Trigger Behavior:**
```sql
CREATE TRIGGER trg_audit_password_change
AFTER UPDATE OF password ON users
FOR EACH ROW
WHEN (OLD.password != NEW.password)
EXECUTE FUNCTION log_password_change();
```

**Effect:**
- Logs password change to password_history table
- Stores timestamp
- Used to enforce "not reuse last N passwords" policy

**Execution:**
```
UPDATE triggered
    ↓
Row updated: password column changed
    ↓
AFTER UPDATE trigger fires (if exists)
    ├─ Check: OLD.password != NEW.password
    ├─ Query password_history table
    ├─ Check if new password was used before
    │  (if policy enforces this)
    └─ Log change to password_history
```

### 6) Transaction & Exception Flow

**Transaction Start:** @Transactional on UserService.changePassword() (line 57)  
**Scope:** Entire method

**Success Path:**
1. findByEmail() retrieves user [SELECT]
2. PasswordEncoder.matches() validates old password
3. New password encoded
4. updatePassword() generates UPDATE
5. Trigger evaluates (if any)
6. Password column updated
7. **@Transactional: COMMIT executed**
8. HTTP 200 OK returned

**Failure Paths:**

**Scenario A: User not found**
```
findByEmail(currentUserEmail) returns empty
    ↓
throw new ResourceNotFoundException("User not found")
    ↓
@Transactional: ROLLBACK (no SQL)
    ↓
HTTP 404 Not Found
```

**Scenario B: Old password incorrect**
```
!passwordEncoder.matches(oldPassword, user.getPassword())
    ↓
throw new InvalidRequestException("Old password is not correct")
    ↓
@Transactional: ROLLBACK
    ↓
HTTP 400 Bad Request: "Old password is not correct"
```

**Scenario C: Password reuse violation (trigger check)**
```
UPDATE executed
    ↓
AFTER UPDATE trigger fires
    ↓
Trigger checks: SELECT 1 FROM password_history WHERE user_id = ? AND password_hash = ?
    ↓
Found in history (password was used before)
    ↓
Trigger raises exception (if policy enforced)
    ↓
Exception propagates
    ↓
@Transactional: ROLLBACK
    ↓
HTTP 400 Bad Request: "Cannot reuse recent passwords"
```

**Scenario D: UPDATE fails (unlikely)**
```
UPDATE executed
    ↓
PostgreSQL constraint error (should not happen)
    ↓
Exception propagates
    ↓
@Transactional: ROLLBACK
    ↓
HTTP 500 Internal Server Error
```

### 7) Final Outcome

**Success:**
```json
{
  "message": "Password changed successfully"
}
```
- Password updated in database
- Hashed with BCrypt
- Audit trail logged (if trigger exists)
- Session invalidated (user must login again)
- HTTP 200 OK

**Failure - Old password wrong:**
```json
{
  "error": "Old password is not correct",
  "status": 400
}
```
- No password change
- HTTP 400 Bad Request

**Failure - Password reuse:**
```json
{
  "error": "Cannot reuse a recent password",
  "status": 400
}
```
- Password NOT updated (trigger prevented)
- HTTP 400 Bad Request

**Failure - User not found:**
```json
{
  "error": "User not found",
  "status": 404
}
```
- HTTP 404 Not Found

---

## Summary: Functions 6-10

| # | Function | Type | SQL | Triggers | TX Scope |
|---|----------|------|-----|----------|----------|
| 6 | save() (AbsenceRequest) | CREATE | INSERT | trg_validate_absence_request_master | Service |
| 7 | reviewRequest() | UPDATE | UPDATE | trg_validate_absence_request_master | Service |
| 8 | updateStatus() (Appointment) | UPDATE | UPDATE | AFTER trigger (release resources) | Service |
| 9 | save() (Service) | CREATE | INSERT | None | Service |
| 10 | updatePassword() | UPDATE | UPDATE | AFTER trigger (audit) | Service |

### Key Patterns

**Complex Triggers (6, 7):**
- ✅ Multi-check validation (dates, overlaps, FK constraints)
- ✅ Pessimistic locking (FOR UPDATE on technician)
- ✅ Conditional checks (only if status=APPROVED)
- ✅ Exception propagation on validation failure

**Simple Operations (9):**
- ✅ Validation in Java-layer
- ✅ No database triggers
- ✅ Straightforward INSERT

**Cascading Effects (8):**
- ✅ UPDATE triggers resource cleanup
- ✅ AFTER UPDATE trigger (not BEFORE)
- ✅ Side effects don't affect main transaction outcome

**Security Critical (10):**
- ✅ Password encoded before binding
- ✅ Old password verification (PasswordEncoder.matches())
- ✅ Audit logging (trigger)

### Complete Exception Propagation Flow (All 10 Functions)

```
Java-level validation failure
    → throw Exception (InvalidRequestException, ResourceNotFoundException, etc.)
    → @Transactional: ROLLBACK (if any SQL executed)
    → Exception propagates to Controller
    → @ControllerAdvice catches
    → HTTP error response (400/403/404/500)

PostgreSQL trigger validation failure
    → RAISE EXCEPTION in trigger
    → PostgreSQL: exception code sent
    → JDBC: SQLException received
    → Hibernate: wraps as PersistenceException
    → Spring: wraps as DataIntegrityViolationException
    → @Transactional: ROLLBACK all changes
    → Exception propagates to Controller
    → HTTP error response (usually 400)

Database constraint violation
    → PostgreSQL: constraint error code
    → Same flow as trigger failure
    → DataIntegrityViolationException
    → HTTP 400 or 409
```

---

**Document:** jpa_6_10.md  
**Token Count:** ~9,200  
**Total with jpa_1_5.md:** ~17,700  
**Remaining Budget:** ~182,300 tokens ✅

All 10 functions documented with complete execution traces.
